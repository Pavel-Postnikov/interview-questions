<h3>
  <img src="../assets/TypeScript.png" width="16" height="16" />
  <span>TypeScript:</span>
</h3>

---
<details><summary><b>Что такое TypeScript?</b></summary>

TypeScript (TS, TScript или «тайпскрипт») — это язык программирования для веб-разработки, основанный на JavaScript.
Делает код понятнее и надежнее, добавляет статическую типизацию (переменные привязаны к конкретным типам данных), а
также может быть скомпилирован в JavaScript. TypeScript используют фронтенд- и бэкенд-разработчики.

Другими словами, TypeScript — это JavaScript ES6 с некоторыми дополнительными возможностями. JavaScript — это язык
сценариев, более похожий на Python, тогда как TypeScript — это объектно-ориентированный язык со статической типизацией,
сравнимый с Java и C#.
</details>

<details><summary><b>Основные компоненты TypeScript?</b></summary>

TypeScript включает в себя три основных компонента:

Язык. Это, с точки зрения разработчиков, самая важная часть TypeScript. «Язык» — это синтаксис, ключевые слова, всё то,
что позволяет писать программы на TypeScript.
Компилятор. TypeScript обладает компилятором с открытым исходным кодом, он является кросс-платформенным, с открытой
спецификацией, и написан на TypeScript. Компилятор выполняет преобразование TypeScript-кода в JavaScript-код. Кроме
того, если с программой что-то не так, он выдаёт сообщения об ошибках. Он позволяет объединять несколько
TypeScript-файлов в один выходной JS-файл и умеет создавать карты кода.
Вспомогательные инструменты. Вспомогательные инструменты TypeScript предназначены для облегчения процесса разработки с
его использованием в различных IDE. Среди них — Visual Studio, VS Code, Sublime, различные средства для быстрого запуска
TS-кода, и другие.

</details>

<details><summary><b>Назовите особенности TypeScript?</b></summary>
- Кроссплатформенность: Компилятор TypeScript можно установить в любой операционной системе: Windows, macOS и Linux.
- Объектно-ориентированный язык: TypeScript предоставляет все стандартные функции ООП, такие как классы, интерфейсы и модули.
- Статическая типизация: TypeScript использует статическую типизацию и помогает проверять типы во время компиляции. Таким образом, вы можете обнаружить ошибки при написании кода без запуска скрипта.
- Необязательная статическая типизация: TypeScript также допускает использование динамической типизации, если вы привыкли к ней в JavaScript.
- Манипуляции с DOM: Вы можете использовать TypeScript для управления DOM для добавления или удаления элементов клиентской веб-страницы.
</details>

<details><summary><b>Плюсы использования TypeScript?</b></summary>

- TypeScript вносит порядок в код.
- Проще дебажить код, т.к. ошибки видны до компиляции еще во время написания кода.
- Статическая типизация TypeScript делает код более читабельным и структурированным чем JavaScript.
- Возможность использования на разных платформах как в клиентских, так и в серверных проектах благодаря универсальной
  транспиляции.

</details>

<details><summary><b>Минусы использования TypeScript?</b></summary>

- Кодирование с помощью TypeScript требует длительного процесса компиляции.
- DefinitelyTyped — в некоторых случаях отсутствуют популярные библиотеки.
- .ts .d.ts .map — большое количество дополнительных файлов после компилирования ts-файла.
- Неявная статическая типизация. Если объявим переменную типа any, то никакой пользы от статической типизации не
  получим.- Шаг компиляции необходим для преобразования TypeScript в JavaScript, если мы хотим запустить приложение
  TypeScript в браузере.

</details>

<details><summary><b>Типы в TypeScript?</b></summary>

**Number:** используется для представления значений чисел. Все числа в TypeScript хранятся как значения с плавающей
запятой.

**String:** представляет собой последовательность символов, хранящуюся как код Unicode UTF-16. Строки заключаются в
одинарные или двойные кавычки.

**Boolean:** логический тип данных. Имеет значение true или false.

**Null:** Null представляет переменную, значение которой не определено.

**Undefined:** литерал, который является отправной точкой всех переменных.

**Void:** тип, присвоенный методам, не имеющим возвращаемого значения.

**Array:** представляет собой коллекцию элементов одного типа.

**Tuple (кортеж):** представляет собой массив с фиксированным количеством элементов разных типов.

**Enum (перечисление):** представляет собой набор именованных констант.

**Any:** представляет любой тип.

**Symbol**

**Never:** также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые
генерируют или возвращают ошибку.
</details>

<details><summary><b>Что такое декораторы?</b></summary>
Декоратор — это специальный вид описания, который можно присоединить к декларации класса, метода, get свойства, свойства или параметра. Декораторы используют форму @expression, то есть при использовании ставится символ @ перед именем декоратора. Хотя по сути expression может быть любая функция. Эта функция будет вызвана в процессе выполнения программы, причем вызывающий код добавит аргументы с информацией о том объекте, который был задекорирован.

Другими словами, декоратор — это способ добавить дополнительное поведение классу, функции, свойству или параметру. При
использовании, среда исполнения сначала вызовет функцию-декоратор, и только потом будет выполнен основной сценарий
объекта (если код декоратора содержит этот вызов). При наличии нескольких декораторов, они будет вызваны по очереди,
сверху вниз.

Пример:

        function MethodDecorator(targer: Object, propertyKey: string, propertyDescriptor) {
            console.log(propertyKey); //printName
            propertyDescriptor.value = function(...args: any[]) {
                return `Hello, ${args}`
            }
        }

        class User {
            name: string

            @MethodDecorator
            printName(name: string): string {
                return name
            } 
        }

        const user = new User();
        console.log(user.printName('Alex')); //Hello, Alex

https://www.youtube.com/watch?v=HU8W-oEi-EA&ab_channel=TechJavascript

https://habr.com/ru/articles/494668/

</details>

<details><summary><b>Поддерживает ли TypeScript перегрузку функций?</b></summary>
Перегрузка функции - это способ определить функцию с несколькими вариантами типов и реализаций. Перегруженная функция может иметь несколько определений, которые отличаются по количеству и типу параметров.

    function add(a: string, b: string): string;
    function add(a: number, b: number): number;
    function add(a: any, b: any): any {
        return a + b;
    }

</details>

<details><summary><b>Разница между типом (`type`) и интерфейсом (`interface`)?</b></summary>

**_Интерфейс_** – именованный тип объекта.

**_Тип_** – задаёт псевдоним для любой разновидности типа, включая примитивные, типы-объекты и пересечения.

- Тип нельзя открыть для добавления новых свойств, интерфейс всегда расширяем (extends ... {});
- Тип нельзя изменить после создания, интерфейс можно;
- Интерфейсы могут использоваться только для объявления форм объектов, а не для переименования примитивов. Оператор type
  позволяет определить новый псевдоним для существующего типа. Оператор фактически добавляет дополнительное имя для
  существующего типа. Новый тип данных при этом не создаётся;
- Интерфейсы поддерживают декларативное слияние, а псевдонимы типов нет. Объявив два или более интерфейса с одинаковыми
  идентификаторами (именами), мы получим один общий интерфейс.

https://htmlacademy.ru/blog/js/types-vs-interfaces
</details>

<details><summary><b>Что такое JSX в TypeScript? Какие режимы JSX поддерживает TypeScript?</b></summary>
JSX - это встраиваемый XML-подобный синтаксис, который позволяет создавать HTML. TypeScript поддерживает встраивание, проверку типов и компиляцию JSX непосредственно в JavaScript.

</details>

<details><summary><b>Что такое директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?</b></summary>
Директивы с тройной косой чертой - это однострочные комментарии, содержащие тег XML для использования в качестве директив компилятора. Каждая директива указывает, что загружать в процессе компиляции. Директивы с тройной косой чертой работают только в верхней части своего файла и будут рассматриваться как обычные комментарии в любом другом месте файла.

    /// <reference path="..." /> - является наиболее распространенной директивой и определяет зависимость между файлами.

    /// <reference types="..." /> - похож на path, но определяет зависимость для пакета.

    /// <reference lib="..." /> - позволяет явно включить встроенный файл lib.

</details>

<details><summary><b>Что такое внешние объявления переменных (ambient declaration) в TypeScript?</b></summary>

Внешнее объявление переменной (ambient declaration) — это механизм, который позволяет сообщать компилятору TypeScript о
том, что некий исходный код существует где-то за пределами текущего файла. Внешние объявления помогают интегрировать в
TS-программы сторонние JavaScript-библиотеки.

Эти объявления делают в файле объявления типов с расширением .d.ts. Внешние переменные или модули объявляют так:

    declare module Module_Name {
    }

Файлы, в которых находится внешний код, должны быть подключены в TS-файле, использующем их, так:

    /// <reference path=" Sample.d.ts"></reference>

</details>

<details><summary><b>Разница между абстрактным классом (abstract class) и интерфейсом (interface)?</b></summary>

**_Абстрактный класс_** — это «заготовка» класса: реализовано большинство методов (включая внутренние), кроме
нескольких.

_**Интерфейс**_ — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных
класса.

Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, один класс хочет дать другому
возможность доступа к некоторым своим методам, но не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и
интерфейс, но тогда нужно будет писать много идентичного кода.
</details>

<details><summary><b>Какие элементы ООП поддерживаются в TypeScript?</b></summary>

- **Классы**;
- **Статические свойства и функции**: для определения статических функций и свойств используется ключевое слово static;
- **Наследование**: одним из ключевых элементов ООП является наследование, которое в TS реализуется c помощью ключевого
  слова extends. При помощи extends мы можем наследовать от базового класса и описать классы наследники;
- **Интерфейсы**: для определения кастомного типа данных без реализации в TS (и не только) используются интерфейсы.
  Чтобы объявить интерфейс, используется ключевое слово Interface;
- **Инкапсуляция**: для сокрытия внешнего доступа к состоянию объекта и управления доступом к этому состоянию, в TS
  используется два модификатора: public и private. Внутри нашего класса мы можем писать недоступные извне методы и
  манипулировать с их помощью. По умолчанию поля и методы имеют доступ public;
- **Generic**: typeScript позволяет создавать Generic-типы.

<code>function имя_функции(имя_переменной: Т): Т</code>

Где Т — тип, которым типизирована функция. Также TS поддерживает типизацию интерфейсов и классов.
</details>

<details><summary><b>Модификаторы доступа в TypeScript?</b></summary>

Модификаторы доступа позволяют сокрыть состояние объекта от внешнего доступа и управлять доступом к этому состоянию. В
TypeScript три модификатора: **_public, protected и private_**.

По умолчанию все члены класса в TypeScript являются **public** (общедоступными). Доступ к ним можно получить где угодно
без каких-либо ограничений.

Если же к свойствам и методам применяется модификатор **private**, то к ним нельзя будет обратиться извне при создании
объекта данного класса;

Модификатор **protected** определяет поля и методы, которые из вне класса видны только в классах-наследниках;
</details>

<details><summary><b>Разница между внутренним (Internal Module) и внешним модулями (External Module)?</b></summary>

**Внешний модуль**

Например. В файле main.d.ts:

    import log = module("log");
    log.message("hello");

Этот ссылается на внешний модуль log, который определен в файле log.ts.

    export function message(s: string) {
        console.log(s);
    }

**Внутренний модуль**

В этом файле есть два внутренних модуля X.Y.Z.

    module A.B.C {
        import XYZ = X.Y.Z;
        export function ping(x: number) {
            if (x > 0) {
                XYZ.pong(x – 1)
            };
        }
    }

    module X.Y.Z {
        import ABC = A.B.C;
        export function pong(x: number) {
            if (x > 0) {
                ABC.ping(x – 1)
            };
        }
    }

</details>

<details><summary><b>Как TypeScript поддерживает необязательные и дефолтные параметры в функции?</b></summary>

В TS можно пометить параметр как **_опциональный_** с помощью ?:

    function f(x?: number) {
        // ...
    }
    f() // OK
    f(10) // OK

Несмотря на то, что тип параметра определен как number, параметр x на самом деле имеет тип number | undefined, поскольку
неопределенные параметры в JS получают значение undefined.

Мы также можем указать **_"дефолтный" параметр_** (параметр по умолчанию):

    function f(x = 10) {
        // ...
    }

Теперь в теле функции f параметр x будет иметь тип number, поскольку любой аргумент со значением undefined будет заменен
на 10. Обратите внимание: явная передача undefined означает "отсутствующий" аргумент.
</details>

<details><summary><b>Что такое перечисление (`enum`)?</b></summary>
В TypeScript enum представляют собой структуры данных постоянной длины, которые содержат набор констант. 

Enum полезны при присвоении свойств или значений, которые могут быть только определенным количеством возможных значений.
Одним из распространенных примеров является значение масти одной карты в колоде игральных карт. Есть только 4 масти и не
существует других возможных значений, и эти значения вряд ли изменятся. По этой причине enum было бы эффективным и ясным
способом описания возможных мастей карты.

    enum Direction {
        Clubs = "Clubs",
        Diamonds = "Diamonds",
        Hearts = "Hearts",
        Spades = "Spades"
    }

</details>

<details><summary><b>Для чего в TypeScript используется `NoImplicitAny`?</b></summary>
Если вы не опишите какой-либо параметр функции, TypeScript присваивает значение any и двигается дальше. Это по существу отключает проверку типов в таких случаях, чего и ожидает разработчик JavaScript. Но это может застать врасплох людей, которые хотят более высокой надёжности. Следовательно, есть опция noImplicitAny, которая при включении будет отмечать случаи, когда тип не может быть определен, например:

    function log(someArg) {
        // Ошибка : someArg имеет неявный тип any
        sendDataToServer(someArg);
    }

Указывается параметр в tsconfig.json файле:

    {
        "compilerOptions": {
            "noImplicitAny": true,
            ...
        }
    }

</details>

<details><summary><b>Разница между типами “Объединение” (`|`) и “Пересечение” (`&`)?</b></summary>

**_Объединение (Union)_** - это мощный механизм, позволяющий создавать из множества существующих типов логическое
условие, по которому данные могут принадлежать только к одному из указанных типов. Объединение указывается с помощью
оператора прямой черты |, по обе стороны которой располагаются типы данных.

Переменной, которой был указан тип объединения A или B или C, может быть присвоено значение, принадлежащее к одному из
трех типов.

    class A {
        a: number;
    }
    class B {
        b: string;
    }
    class C {
        c: boolean;
    }

    // значение может принадлежать только одному типу (A или B или C)
    let identifier: A | B | C;

**_Пересечение (Intersection)_** — ещё один мощный механизм TypeScript, который позволяет рассматривать множество типов
данных как единое целое. Пересечение указывается с помощью оператора амперсанда &, по обе стороны которого указываются
типы данных.

Переменной, которой был указан тип пересечение A и B и С, должно быть присвоено значение, принадлежащее к типам A и B и
C одновременно. Другими словами, значение должно обладать всеми обязательными признаками каждого типа, определяющего
пересечение.

    class A {
        a: number;
    }
    class B {
        b: string;
    }
    class C {
        c: boolean;
    }

    let name: A & B & C; // значение должно принадлежать ко всем типам одновременно

</details>

<details><summary><b>Что такое общие типы (`generic`) в TypeScript?</b></summary>

Обобщённые типы (generics) позволяют создавать компоненты или функции, которые могут работать с различными типами, а не
с каким-то одним.

    //1
    function identity<T>(arg: T): T {
	    return arg;
    }

    let output1 = identity<string>("myString");
    let output2 = identity<number>(100);


    //2
    const AC1 = (age: number) => ({type: 'SET-AGE', age});
    const AC1 = ReturnType<typeof AC1> //создай тип функции AC1 и верни возвращаемый тип


    //3 (ConditionalTypes)
    type HipHopType<T> = T extends 'user' ? UserType : ProtoType;
    
    type MyReturnType<T> = T extends (...args: any) => infer R ? R : never; //infer – определи тип
    
    type SameType<T> = T extends {[key: string]: infer U} ? U : never;

https://www.youtube.com/watch?v=RKrkQxFYJ1c&t=25s&ab_channel=IT-KAMASUTRA
</details>

<details><summary><b>Какие области видимости доступны в TypeScript?</b></summary>

**Глобальная:** определяется вне любого класса и может использоваться в любом месте программы.

**Область видимости функции / класса:** переменные, определенные в функции или классе, могут использоваться в любом
месте в пределах этой области.

**Локальная область действия / блок кода:** переменные, определенные в локальной области видимости, могут использоваться
в любом месте этого блока.
</details>

<details><summary><b>Что такое `.map` файл, как и зачем его использовать?</b></summary>

Файл map - это исходная карта, которая показывает, как исходный код TypeScript был интерпретирован в пригодный для
использования код JavaScript. Они помогают упростить отладку, поскольку вы можете отловить любое странное поведение
компилятора.

Инструменты отладки также могут использовать эти файлы, чтобы вы могли редактировать базовый TypeScript, а не
создаваемый файл JavaScript.

    {
        "version":3,
        "file":"index.js",
        "sourceRoot":"",
        "sources":["../src/index.ts"],
        "names":[],
        "mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AAEvC,SAAS,SAAS;IACd,MAAM,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;",
        "sourcesContent": []
    }

Обычно, имя map-файла складывается из имени скрипта, к которому он относится, с добавлением расширения ".map", bundle.js
— bundle.js.map. Это обычный json-файл со следующими полями:

- «version» — версия Source Maps;
- «file» — (опционально) имя сгенерированного файла, к которому относится текущий map-файл;
- «sourceRoot» — (опционально) префикс для путей к файлам-исходникам;
- «sources» — список путей к файлам-исходникам (разрешаются аналогично адресам src тега script, можно использовать file:
  //.);
- «names» — список имен переменных и функций, которые подверглись изменению в сгенерированном файле;
- «mappings» — координаты отображения переменных и функций исходных файлов на сгенерированный файл в формате Base64 VLQ;
- «sourcesContent» — (опционально) в случае self-contained map-файла список строк, каждая из которых содержит исходный
  текст файла из sources;

Код файлов-исходников можно включить непосредственно в map-файл в поле «sourcesContent», при наличии этого поля
необходимость в их отдельной загрузке отпадает. В этом случае названия файлов в «sources» не отражают их реального
адреса и могут быть совершенно произвольными. Именно поэтому, вы можете видеть во вкладке Sources DevTools такие
странные «протоколы»: webpack://, ng:// и т.д

</details>

<details><summary><b>Можно ли использовать TypeScript в серверной разработке?</b></summary>

Программы, написанные на TypeScript, подходят не только для фронтенд-разработки, но и для создания серверных приложений.
Например, на TS можно писать программы для платформы Node.js. Это даёт программисту дополнительные средства по контролю
типов и позволяет использовать другие возможности языка. Для создания серверных приложений на TS нужно лишь наладить
правильный процесс обработки кода, на вход которого поступают TypeScript-файлы, а на выходе получаются JavaScript-файлы,
подходящие для выполнения их в Node.js. Для того чтобы организовать такую среду, сначала надо установить компилятор
TypeScript:

    npm i -g typescript

Параметры компилятора задают с помощью файла tsconfig.json, который определяет, кроме прочего, цель компиляции и место,
в которое нужно поместиться готовые JS-файлы. В целом, этот файл очень похож на конфигурационные файлы babel или
webpack:

    {
        "compilerOptions": {
            "target": "es5",
            "module": "commonjs",
            "declaration": true,
            "outDir": "build"
        }   
    }

Теперь, при условии, что компилятору есть что обрабатывать, нужно его запустить:

    tsc

И, наконец, учитывая то, что JS-файлы, пригодные для выполнения в среде Node.js, находятся в папке build, надо выполнить
такую команду, находясь в корневой директории проекта:

    node build/index.js

</details>

<details><summary><b>Для чего в TypeScript используют ключевое слово `declare`?</b></summary>
Ключевое слово declare используется в TypeScript для объявления переменных, источником которых может служить некий файл, не являющийся TypeScript-файлом.

Например, представим, что у нас имеется библиотека, которая называется myLibrary. У неё нет файла с объявлениями типов
TypeScript, у неё имеется лишь пространство имён myLibrary в глобальном пространстве имён. Если вы хотите использовать
эту библиотеку в своём TS-коде, вы можете использовать следующую конструкцию:

    declare var myLibrary;

TypeScript назначит переменной myLibrary тип any. Проблема тут заключается в том, что у вас не будет, во время
разработки, интеллектуальных подсказок по этой библиотеке, хотя использовать её в своём коде вы сможете. В этой ситуации
можно воспользоваться и другим подходом, ведущим к тому же результату. Речь идёт об использовании переменной типа any:

    var myLibrary: any;

И в том и в другом случае при компиляции TS-кода в JavaScript, получится одно и то же, но вариант с использованием
ключевого слова declare отличается лучшей читабельностью. Применение этого ключевого слова приводит к созданию так
называемого внешнего объявления переменной (ambient declaration).
</details>

<details><summary><b>Разница между типами `void`, `never` и `unknown`?</b></summary>

**_void_** – этот тип означает отсутствие конкретного типа. Основное предназначение — явно указывать на то, что у
функции или метода отсутствует возвращаемое значение (либо return нет, либо он пустой);

**_never_** – служит для указания того, что какие-либо операции никогда не будут выполнены, например, если функция
выбрасывает исключение (throw new Error("")). Тип never можно указать только той функции, из которой программа
действительно никогда не сможет выйти;

**_unknown_** – является типобезопасным аналогом типа any, но запрещает делать любые операции. Все типы совместимы с
типом unknown, в то время как сам тип unknown совместим только с самим собой и типом any.
</details>

<details><summary><b>Как вы отлавливаете ошибки в TypeScript коде?</b></summary>

- try/catch
- tsconfig.json флаг "strict": true, который включает сразу несколько проверок

https://medium.com/nuances-of-programming/%D0%BF%D1%80%D0%BE%D1%84%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%B2-typescript-c2e187a4efb5
</details>
---
