<h3>
  <img src="../assets/JSDom.png" width="16" height="16" />
  <span>JS in Browser:</span>
</h3>

---
<details><summary><b>Что такое DOM?</b></summary>
DOM — это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML-кода, полученного им от сервера. Иными словами, это представление HTML-документа в виде дерева тегов.

Или проще, DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью события DOMContentLoaded. С переменной document начинается любая работа с HTML-разметкой в JavaScript.

DOM отличается от исходного html-документа:
- Это всегда верный html-код;
- Может быть изменен с помощью JS (?)
- В него не входят псевдо-элементы (::after);
- Входят скрытые элементы (display: none).

**Shadow DOM**

Shadow DOM был создан для обеспечения возможности изоляции и компонентизации непосредственно на веб-платформе без необходимости полагаться на такие инструменты, как iframe.
Это собственное изолированное дерево DOM со своими элементами и стилями, полностью изолированное от исходного DOM.
Теневой DOM не использует глобальные стили документа и всегда присоединен к элементу в обычном DOM.

**Virtual DOM**

Это инструмент, который позволяет нам взаимодействовать с элементами DOM более простым и производительным способом. Это JavaScript-объектное представление DOM, которое мы можем изменять так часто, как нам нужно. Изменения, внесенные в этот объект, затем сопоставляются, а изменения в реальном DOM производятся намного реже.

https://blog.skillfactory.ru/glossary/dom/
https://doka.guide/js/dom/
https://alishoff.com/blog/256

</details>

<details><summary><b>Типы узлов DOM-дерева?</b></summary>

Основную структуру DOM-дерева составляют именно узлы, образованные HTML-тегами. Их называют узлами-элементами или просто элементами.

Узнать тип узла в DOM можно с помощью свойства nodeType.
Это свойство возвращает число от 1 до 12, обозначающее тип узла. На практике в основном работают с 4 из них:

document – «входная точка» в DOM.

узлы-элементы – HTML-теги, основные строительные блоки.

текстовые узлы – содержат текст.

комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
</details>

<details><summary><b>Методы поиска элементов в DOM?</b></summary>

- **getElementById**: Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id);
- **querySelectorAll**: он возвращает все элементы внутри document, удовлетворяющие данному CSS-селектору (document.querySelectorAll('ul > li:last-child'));
- **querySelector**: возвращает первый элемент, соответствующий данному CSS-селектору;
- **elem.matches**: ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false;
- **elem.closest**: поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден*;
- **elem.getElementsByTagName(tag)** ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
- **elem.getElementsByClassName(className)** возвращает элементы, которые имеют данный CSS-класс.
- **document.getElementsByName(name)** возвращает элементы с заданным атрибутом name. Очень редко используется.
- **elemA.contains(elemB)** вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

https://learn.javascript.ru/searching-elements-dom

</details>

<details><summary><b>Свойства для перемещения по DOM-дереву?</b></summary>
Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.

Самые верхние элементы дерева доступны как свойства объекта document:

- Самый верхний узел документа: document.documentElement. В DOM он соответствует тегу <html>.
- Другой часто используемый DOM-узел – узел тега body: document.body.
- Тег head доступен как document.head.

Есть два основных набора ссылок:

- Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.

Коллекция childNodes содержит список всех детей, включая текстовые узлы.

Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

- Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:

children – коллекция детей, которые являются элементами.

firstElementChild, lastElementChild – первый и последний дочерний элемент.

previousElementSibling, nextElementSibling – соседи-элементы.

parentElement – родитель-элемент.

Свойство parentElement возвращает родитель-элемент, а parentNode возвращает «любого родителя». Обычно эти свойства одинаковы: они оба получают родителя.

За исключением document.documentElement:

    alert( document.documentElement.parentNode ); // выведет document
    alert( document.documentElement.parentElement ); // выведет null
Причина в том, что родителем корневого узла document.documentElement (<html>) является document. Но document – это не узел-элемент, так что parentNode вернёт его, а parentElement нет.

Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.


https://learn.javascript.ru/dom-navigation

</details>

<details><summary><b>Разница между attribute и property у DOM-элементов?</b></summary>

**Свойство** – это то, что находится внутри DOM-объекта.

Обратим внимание, пользовательские DOM-свойства:

- Могут иметь любое значение.
- Названия свойств чувствительны к регистру.
- Работают за счёт того, что DOM-узлы являются объектами JavaScript.

**Атрибуты** – это то, что написано в HTML.

Доступ к атрибутам осуществляется при помощи стандартных методов:

- elem.hasAttribute(name) – проверяет наличие атрибута
- elem.getAttribute(name) – получает значение атрибута
- elem.setAttribute(name, value) – устанавливает атрибут
- elem.removeAttribute(name) – удаляет атрибут
- elem.attributes – возвращает все атрибуты элемента

В отличие от свойств, атрибуты:

- Всегда являются строками.
- Их имя нечувствительно к регистру (ведь это HTML)
- Видны в innerHTML (за исключением старых IE)

Синхронизация между атрибутами и свойствами:

- Стандартные свойства и атрибуты синхронизируются: установка атрибута автоматически ставит свойство DOM. Некоторые свойства синхронизируются в обе стороны.
- Бывает так, что свойство не совсем соответствует атрибуту. Например, «логические» свойства вроде checked, selected всегда имеют значение true/false, а в атрибут можно записать произвольную строку.Выше мы видели другие примеры на эту тему, например href.

Нестандартные атрибуты:

- Нестандартный атрибут (если забыть глюки старых IE) никогда не попадёт в свойство, так что для кросс-браузерного доступа к нему нужно обязательно использовать getAttribute.
- Атрибуты, название которых начинается с data-, можно прочитать через dataset. Эта возможность не поддерживается IE10-.

Для того, чтобы избежать проблем со старыми IE, а также для более короткого и понятного кода старайтесь везде использовать свойства, а атрибуты – только там, где это действительно нужно.

А действительно нужны атрибуты очень редко – лишь в следующих трёх случаях:

1. Когда нужно кросс-браузерно получить нестандартный HTML-атрибут.
2. Когда нужно получить «оригинальное значение» стандартного HTML-атрибута, например, input value="...".
3. Когда нужно получить список всех атрибутов, включая пользовательские. Для этого используется коллекция attributes.

4. Если вы хотите использовать собственные атрибуты в HTML, то помните, что атрибуты с именем, начинающимся на data- валидны в HTML5 и современные браузеры поддерживают доступ к ним через свойство dataset.

https://learn.javascript.ru/attributes-and-custom-properties

</details>

<details><summary><b>Что такое BOM?</b></summary>

Окружение предоставляет языку дополнительные возможности и функции. Браузерное окружение, например, даёт возможность работать со страницами сайтов.

Представление этих дополнительных возможностей и функциональности в виде объектов, к которым у языка есть доступ — это объектная модель.

В случае с браузерным окружением — это объектная модель браузера (Browser Object Model, BOM). Она предоставляет доступ к navigator, location, fetch и другим объектам.

Объект **navigator** содержит информацию о браузере: название, версия, платформа, доступные плагины, доступ к буферу обмена и прочее. Это один из самых больших объектов в окружении.

С помощью этого объекта можно узнать, разрешён ли доступ к кукам, получить доступ к буферу обмена, геолокации, узнать, с какого браузера пользователь смотрит на страницу через userAgent.

Объект **screen** содержит информацию об экране браузера.

width и height указывают ширину и высоту экрана в пикселях соответственно. avail-метрики указывают, сколько ширины и высоты доступно — то есть ширину и высоту с учётом интерфейсных деталей браузера типа полос прокрутки.

Объект **location** даёт возможность узнать, на какой странице мы находимся (какой у неё URL) и перейти на другую страницу программно.

- href содержит URL целиком, включая в себя полный адрес хоста, страницы и все query-параметры.
- host и hostname указывают имя хоста. Разница между ними в том, что host включает в себя порт. Если бы мы стучались не на [google.com](http://google.com), а на google.com:8080, то host содержал бы значение www.google.com:8080, в то время как hostname остался бы тем же.
- pathname указывает путь от корня адреса до текущей страницы.
- search указывает query-параметры, которые находятся в адресной строке, если они есть.
- hash указывает хеш (ID элемента после #) страницы. Его ещё называют якорем, потому что при переходе на страницу с хешем браузер найдёт элемент с ID, равным этому хешу, и прокрутит страницу к этому элементу.

Если мы хотим изменить адрес и перейти на другую страницу, мы можем указать новый location.href:

    location.href = 'https://yandex.ru'

**fetch** предоставляет возможность работы с сетью, с его помощью можно отправлять запросы на сервер.

**history** даёт доступ к истории браузера, которая ограничена текущей вкладкой. То есть с её помощью можно перейти на страницу назад, только если мы пришли с неё.

Чтобы перемещаться по истории назад и вперёд, можно использовать методы back() и forward().

Для более точного управления историей рекомендуется использовать pushState() и replaceState().

Методы pushState() и replaceState() принимают три параметра:

- state — любые данные, которые связаны с переходом;
- unused — неиспользуемый параметр, который существует по историческим причинам;
- url (необязательный) — url адрес новой записи в истории.

      // state — данные для новой записи в истории
      const state = { user_id: 5 }

      // unused — для совместимости рекомендуется передавать пустую строку:
      const unused = ''

      // url — url адрес который будет добавлен в адресную строку:
      const url = '/another-page/'

history.pushState(state, unused, url)

**localStorage, sessionStorage** используются, чтобы хранить какие-то данные в браузере пользователя.

Они удобны, когда мы не хотим отправлять данные на сервер, потому что они, например, промежуточные, или нужны только на клиенте.

https://doka.guide/js/bom/
</details>

<details><summary><b>Виды событий в JavaScript?</b></summary>

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Вот список самых часто используемых DOM-событий, пока просто для ознакомления:

События мыши:
- click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
- contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
- mouseover / mouseout – когда мышь наводится на / покидает элемент.
- mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
- mousemove – при движении мыши.

События на элементах управления:
- submit – пользователь отправил форму form.
- focus – пользователь фокусируется на элементе, например нажимает на input.

Клавиатурные события:

keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:

DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен. 

CSS events:

transitionend – когда CSS-анимация завершена.

https://itchief.ru/javascript/browser-events

</details>

<details><summary><b>Как добавить обработчик события на DOM-элемент?</b></summary>

Чтобы "повесить" обработчик событий на наш элемент button, нужно использовать специальный метод - addEventListener. Этот метод принимает 2 аргумента:

- Тип события (мы будем "слушать" событие "click").
Так называемую колбэк (callback) функцию, которая запускается после срабатывания нужного события.
 
        const button = document.querySelector('.btn');
            function handleClick() {
                console.log('click');
            }
        button.addEventListener('click', handleClick);


Третий аргумент captureOrOptions метода addEventListener:

    element.addEventListener(eventType, handler[, captureOrOptions]);

позволяет вам перехватывать события на разных этапах их распространения.

- Если аргумент captureOrOptions пропущен, имеет значение false или { capture: false }, обработчик будет захватывать события на "Фазе цели" и "Фазе всплытия"
- Если же аргумент captureOrOptions имеет значение true или `{ capture: true }, обработчик сработает уже на "Фазе захвата (погружения)"

</details>

<details><summary><b>Как удалить обработчик события с DOM-элемента?</b></summary>

Чтобы снять обработчик события с какого-либо элемента, нужно использовать метод removeEventListener. В качестве аргументов нужно указать не только название события ("click"), но и название коллбэк функции, которая привязана к элементу.

    buttonTwo.removeEventListener('click', handleClick);

Метод removeEventListener не сработает, если в качестве коллбэк функции использовать безымянную функцию, так как будет отсутствовать возможность сослаться на нее.
</details>

<details><summary><b>Что такое распространение события (Event Propagation)?</b></summary>

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента.

Распространение события имеет три стадии или фазы:

1. Фаза погружения (захвата, перехвата) (Capture phase) — событие возникает в объекте Window и опускается до цели события через всех ее предков.

2. Целевая фаза (Target phase) — это когда событие достигает целевого элемента.

3. Фаза всплытия (Bubbling phase) — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.

</details>

<details><summary><b>Что такое делегирование событий (Event Delegation)?</b></summary>
Идея делегирования событий проста: вместо прикрепления обработчиков событий прямо к кнопкам, мы делегируем отслеживание этого события родительскому элементу div id="buttons". Когда нажимается кнопка, обработчик, назначенный родительскому элементу ловит всплывающее событие.

Использование делегирования событий требует 3 шагов:

**Шаг 1. Определить общего родителя элементов для отслеживания событий**

В примере ниже div id="buttons" является общим родителем для кнопок.


**Шаг 2. Прикрепить к родительскому элементу обработчик событий**
    
    document.getElementById('buttons').addEventListener('click', handler) прикрепляет обработчик событий к родителю кнопок. Этот обработчик также реагирует на нажатия на кнопки, так как события нажатий на кнопки всплывают по всем элементам-предкам (благодаря распространению событий).


**Шаг 3. Использовать event.target для выбора целевого элемента**

Когда кнопка нажата, функция-обработчик вызывается с аргументом: объектом event. Свойство event.target обращается к элементу, на котором произошло событие:


    // ...
    .addEventListener('click', event => {
      if (event.target.className === 'buttonClass') {
        console.log('Click!');
      }
    });

На элемент к которому прикреплён сработавший обработчик события, указывает event.currentTarget. В примере event.currentTarget указывает на элемент div id="buttons".

    <div id="buttons"> <!-- Шаг 1 -->
      <button class="buttonClass">Click me</button>
      <button class="buttonClass">Click me</button>
      <!-- Кнопки... -->
      <button class="buttonClass">Click me</button>
    </div>
    
    <script>
      document.getElementById('buttons')
        .addEventListener('click', event => { // Step 2
          if (event.target.className === 'buttonClass') { // Step 3
            console.log('Click!');
          }
    });
    </script>
</details>

<details><summary><b>Как использовать media выражения в JavaScript?</b></summary>

Чтобы определить, соответствует ли документ строке медиа-запроса в JavaScript, используется метод matchMedia().

Использование почти идентично медиа-запросам CSS. Мы передаем строку медиа-запроса в matchMedia(), а затем проверяем свойство .matches.

    const mediaQuery = window.matchMedia('(min-width: 768px)')

Определенный медиа-запрос вернет объект MediaQueryList. Это объект, в котором хранится информация о медиа-запросе и ключевом свойстве, которое нам нужно для .matches. Это логическое свойство только для чтения, которое возвращается true, если документ соответствует медиа-запросу.

MediaQueryList имеет метод addListener() (и последующие removeListener()), который принимает функцию обратного вызова (представленную событием .onchange), которая вызывается при изменении статуса медиа-запроса. Другими словами, мы можем запускать дополнительные функции при изменении условий, что позволяет нам «реагировать» на обновленные условия.

    const mediaQuery = window.matchMedia('(min-width: 768px)')

    function handleTabletChange(e) {
      if (e.matches) {
        console.log('Media Query Matched!')
      }
    }
    
    mediaQuery.addListener(handleTabletChange)
    
    handleTabletChange(mediaQuery)

Изначально addListener() не срабатывает, из-за чего нужно вызвать функцию обработчика событий вручную и передать медиа-запрос в качестве аргумента.
</details>

<details><summary><b>Расскажите про координаты в браузере?</b></summary>

Чтобы перемещать и позиционировать элементы на экране в браузере имеется система координат. Оси координат начинаются в левом верхнем углу экрана и идут вправо для оси x и вниз для оси y.

Позиционирование с помощью координат может быть относительно окна браузера или относительно отдельного элемента. Всего существует две системы координат: одна начинается от угла HTML-страницы (документа), а вторая от угла окна браузера. С помощью первой можно определять как элемент расположен относительно всей страницы, а с помощью второй – как элемент расположен относительно окна браузера и того что там находится. Объекты события мыши и тач-события содержат координаты места на экране и в документе, где событие произошло: pageX/pageY – для документа, clientX/clientY – для экрана.

Координатами элемента является расстояние в пикселях от осей системы координат до его левого верхнего угла. С помощью метода элемента getBoundingClientRect() можно получить подробные данные о координатах элемента и его размере.

Если нужно узнать как элемент расположен относительно **_окна_**, то в этом поможет метод getBoundingClientRect(). Вызов этого метода возвращает объект с полями x, y, top, left, right, bottom, width и height, то есть полная информация о геометрии элемента. В полях x и y содержатся координаты элемента.

Информацию о том, как элемент расположен относительно **_документа_** нельзя узнать из какого-то свойства или метода, её необходимо вычислять самостоятельно. Самым простым способом это можно сделать сложив координаты относительно окна из метода getBoundingClientRect() со смещением самого окна относительно документа. Смещение окна браузера можно узнать из полей window.pageXOffset и window.pageYOffset – это число пикселей на которое прокручен документ по горизонтали и вертикали.

    const rect = element.getBoundingClientRect()

    console.log('Смещение X относительно документа:', rect.x + window.pageXOffset)
    console.log('Смещение Y относительно документа:', rect.y + window.pageYOffset)

https://doka.guide/js/coordinates/
</details>

<details><summary><b>Разница между HTMLCollection и NodeList?</b></summary>

HTMLCollection и NodeList — это очень похожие на массив коллекции. Они хранят элементы веб-страницы (узлы DOM). NodeList может хранить любые типы узлов, а HTMLCollection — только узлы HTML элементов. К элементам коллекций можно обращаться по индексу, но у них нет привычных методов массива.

**HTMLCollection** возвращают методы getElementsByTagName() и getElementsByClassName().
Полученная один раз коллекция всегда остаётся актуальной — JavaScript будет обновлять её в случае, если на странице появляется подходящий элемент. Поэтому HTMLCollection называют «живой» коллекцией.

**NodeList** возвращают метод querySelectorAll() и свойство childNodes.

Разница:

- NodeList может хранить любые типы узлов, например текстовые узлы и комментарии, а HTMLCollection — только узлы HTML элементов;
- HTMLCollection позволяет обращаться к элементам не только по индексу, но и по имени с помощью метода namedItem;
- NodeList может быть не только «живой» коллекцией, но и статической. Такая коллекция не обновляется при появлении на странице новых элементов.

«Живой» NodeList возвращают метод getElementsByName() и свойство childNodes.

Статический NodeList возвращает метод querySelectorAll().

https://doka.guide/js/htmlcollection-and-nodelist/
</details>

<details><summary><b>Как динамически добавить элемент на HTML-страницу?</b></summary>

DOM-узел можно создать двумя методами:
- document.createElement(tag) – cоздаёт новый элемент с заданным тегом:


    let div = document.createElement('div');

- document.createTextNode(text) – cоздаёт новый текстовый узел с заданным текстом:


    let textNode = document.createTextNode('А вот и я')

Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body.

Для этого есть метод append, в нашем случае: document.body.append(div).

Вот методы для различных вариантов вставки:

- node.append(...nodes or strings) – добавляет узлы или строки в конец node,
- node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
- node.before(...nodes or strings) –- вставляет узлы или строки до node,
- node.after(...nodes or strings) –- вставляет узлы или строки после node,
- node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.

Если мы хотим вставить HTML именно «как html», со всеми тегами и прочим, как делает это elem.innerHTML, то с этим поможет **insertAdjacentHTML/Text/Element**.

Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:

- "beforebegin" – вставить html непосредственно перед elem,
- "afterbegin" – вставить html в начало elem,
- "beforeend" – вставить html в конец elem,
- "afterend" – вставить html непосредственно после elem.

Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».

    <div id="div"></div>
    <script>
      div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
      div.insertAdjacentHTML('afterend', '<p>Пока</p>');
    </script>

    //Приведёт к ...
    <p>Привет</p>
    <div id="div"></div>
    <p>Пока</p>
</details>

<details><summary><b>Разница между feature detection, feature inference и анализом строки user-agent?</b></summary>

**Feature detection** (определение возможностей браузера)

Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода - и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:

    if ('geolocation' in navigator) {
      // Можно использовать navigator.geolocation
    } else {
      // Обработка отсутствия возможности
    }

**Feature inference** (предположение возможностей)

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует, например:

Или, если **_x_** существует, мы можем предположить, что **_y_** существует

    if('localStorage' in window){
      window.sessionStorage.setItem("this-should-exist-too", 1);
    }
или

    if('localStorage' in window){
      window.sessionStorage.setItem("this-should-exist-too", 1);
    }

**Строка User Agent**

Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя от которого исходит запрос. Доступ к ней можно получить через navigator.userAgent. Тем не менее, строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome, так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте этого метода.

    if (navigator.userAgent.indexOf("MSIE 7") > -1){
      //do something
    }
</details>

<details><summary><b>Разница между `e.preventDefault()` и `e.stopPropagation()`?</b></summary>

Для понимания сути происходящего возьмем фрагмент html-кода, который будет использоваться в приведенных ниже примерах:

    <div>
        <a href="http://www.codius.ru">
            Главная страница
        </a>
    </div>

**preventDefault()** — предотвращает выполнение стандартного действия на событие:

    $(document).ready(function () {
      $('a').click(function (e) {
        e.preventDefault();
        //При клике на ссылку переход на страницу http://www.codius.ru осуществлен не будет.
      });
    });

**stopPropagation()** — прекращает распространение события к родительским элементам:

    $(document).ready(function () {
      $('a').click(function (e) {
        e.stopPropagation();
        //При клике на ссылку переход на страницу http://www.codius.ru осуществлен не будет.
      });
      $('div').click(function (e) {
        alert('Это сообщение не появится, так распространение события было остановлено');
      });
    });

**stopImmediatePropagation()** — прекращает распространение события к родительским элементам и прекращает обработку этого события всеми последующими обработчиками:

    $(document).ready(function () {
      $('a').click(function (e) {
        e.stopImmediatePropagation();
      });
      $('a').click(function (e) {
        alert('Обработчик 2. Это сообщение не появится, так как распространение события к родительским элементам было остановлено');
      });
      $('a').click(function (e) {
        e.stopImmediatePropagation();
        alert('Обработчик 3. Это сообщение не появится, так как распространение события к родительским элементам было остановлено');
      });
    });
</details>

<details><summary><b>Разница между `event.target` и `event.currentTarget`?</b></summary>

Каждый обработчик имеет доступ к свойствам события:

- event.target – самый глубокий элемент, на котором произошло событие.
- event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие).
- event.eventPhase – на какой фазе он сработал (погружение =1, всплытие = 3).

Свойство **currentTarget** содержит объект, на которого была совершена подписка (у которого вы вызывали addEventListener ). В свою очередь свойство **target** содержит объект, который непосредственно рассылает событие.
</details>

<details><summary><b>Разница между событиями `load` и `DOMContentLoaded`?</b></summary>

Если нужно запустить JavaScript-код после того, как страница загрузилась, то нужно подписаться на одно из событий у объекта window:

**DOMContentLoaded** — событие происходит, когда браузер разобрал HTML-страницу и составил DOM-дерево;

**load** — событие происходит, когда загрузилась и HTML страница, и все ресурсы для её отображения пользователю: стили, картинки и так далее.

DOMContentLoaded всегда происходит раньше, чем load. Чем больше стилей и картинок на странице, тем больше разница во времени между срабатыванием этих событий.

</details>
<details><summary><b>Разница между `innerHTML` и `outerHTML`?</b></summary>

`<p id="pid">welcome</p>`

innerHTML of element "pid" == welcome
outerHTML of element "pid" == `<p id="pid">welcome</p>`
</details>

<details><summary><b>Разница между `JSON` и `XML`?</b></summary>

JSON — это сокращение от JavaScript Object Notation. JSON использует читаемый текст для хранения и передачи данных, содержащих массивы и значения пар атрибутов. Текст JSON можно легко преобразовать в объект JavaScript внутри JSON, а затем отправить на сервер. Он основан на JavaScript и эффективно используется с множеством языков программирования.

XML — это обширный язык разметки, созданный для переноса данных. Он определяет некоторый стандартный набор правил для кодирования файлов в читаемом формате. Цель разработки этого XML — сосредоточиться на простоте и удобстве использования в Интернете. Это сильно поддерживается через Unicode. Это один из наиболее широко используемых языков для представления произвольных структур данных.

- JSON — это нотация объектов JavaScript для форматирования данных, тогда как XML — это язык разметки;
- JSON имеет меньший размер файла и эффективно передает данные в Интернет по сравнению с XML;
- JSON обращается к данным через объекты JSON, тогда как XML требует анализа данных;
- JSON легко читается, поскольку имеет более организованную структуру кода. С другой стороны, XML трудно интерпретировать из-за его сложной структуры;
- JSON хорош для передачи данных, поскольку он не требует обработки, тогда как XML может быть сложным, поскольку он позволяет не только передавать данные, но также обрабатывать и форматировать файлы;
- JSON наименее безопасен в отличие от XML;
- JSON не может поддерживать пространства имен, но способен полностью поддерживать инструментарий Ajax. Напротив, XML поддерживает пространства имен, но не может поддерживать инструменты Ajax;
- JSON хранит данные как карту, XML, напротив, хранит данные как древовидную структуру. Кроме того, JSON использует массивы, но не имеет закрывающих тегов.

https://bestprogrammer.ru/izuchenie/json-ili-xml-v-chem-raznitsa
https://appmaster.io/ru/blog/json-protiv-xml
</details>

<details><summary><b>Для чего используется свойство `window.navigator`?</b></summary>

Свойство window.navigator возвращает объект описания приложения (user agent), которое выполняет скрипт. В подавляющем большинстве случаев это приложение — браузер. Объект содержит свойства, описывающие браузер, и методы для выполнения действий.

Часто используемые свойства:

_**userAgent**_ возвращает строку, которая содержит название браузера. Не стоит использовать это свойство, чтобы определить браузер пользователя! Спецификация рекомендует браузерам передавать минимум информации в userAgent, значение может меняться от версии к версии.

_**language**_ возвращает предпочитаемый язык интерфейса в виде языкового тега. Например, en, ru, en-US и т.д. Обычно это язык, установленный в настройках браузера.

_**languages**_ возвращает массив предпочитаемых языков в порядке предпочтительности. Первый в списке будет язык, который возвращает navigator.language.

_**cookieEnabled**_ возвращает true, если браузер пользователя поддерживает куки и они включены, false в противном случае.

_**onLine**_ возвращает true, если у пользователя есть подключение к сети. Браузеры вкладывают разные смыслы в понятие «онлайн», поэтому это свойство — ненадёжный источник данных.

Методы объекта navigator служат для взаимодействия с другими WebAPI. Например, метод vibrate, который вызывает вибрацию пользовательского устройства, если она поддерживается: navigator.vibrate(200)
</details>

<details><summary><b>Для чего используется метод `.focus()`?</b></summary>

Вызов метода focus() на DOM-элементе устанавливает фокус на этот элемент. Когда элемент находится в фокусе, он перехватывает и обрабатывает события клавиатуры.

Фокус нельзя поставить на элемент, если он заблокирован. Например, если у кнопки или поля ввода стоит атрибут disabled.

Метод focus() обычно вызывается без аргументов, но в него также можно передать объект со свойством preventScroll.

По умолчанию браузер прокручивает страницу до элемента, на который перемещён фокус. Это так же происходит, если preventScroll установлен в false. Если preventScroll установлен в true, то прокрутки страницы к элементу не произойдёт.

Если не устанавливать атрибуты, которые влияют на доступность элемента для фокуса, то каждый браузер самостоятельно определяет, какой элемент может иметь фокус. Во всех современных браузерах, следующие элементы могут иметь фокус:

- ссылки `<a>` с установленным атрибутом href;
- кнопки `<button>`;
- поля ввода `<input>`, кроме скрытых (type="hidden");
- выпадающие списки `<select>`;
- поля многостраничного ввода textarea;
- элементы `<summary>`;
- произвольный элемент, если у него установлен атрибут tabindex.
</details>

<details><summary><b>Для чего используется свойство `.forms`?</b></summary>

forms — это поле объекта document. При обращении к свойству forms мы получим живую коллекцию HTMLCollection.

Формы, у которых указаны атрибуты id или name, можно получить по значениям этих атрибутов. В остальных случаях получить форму можно по индексу, который совпадает с порядком описания форм на странице.

https://doka.guide/js/forms/
</details>

<details><summary><b>Для чего используется метод `.scrollIntoView()`?</b></summary>

Метод scrollIntoView() позволяет программно прокрутить окно до определённого элемента.

    const element = document.querySelector('#about')

    element.scrollIntoView()

В scrollIntoView() можно передать аргумент типа boolean:
- Если указать true, то скролл окна остановится у верхней границы элемента;
- Если указать false, то у нижней границы.

Ещё в scrollIntoView() можно передать объект с опциями скролла, где:
- behavior отвечает за анимацию прокрутки. Принимает smooth, чтобы было плавно, по умолчанию резкое auto;
- block за вертикальное выравнивание. Принимает start, center, end и nearest;
- inline за горизонтальное выравнивание. Принимает то же, что и block.

</details>

<details><summary><b>Разница между методами `.submit()` и `.requestSubmit()`?</b></summary>

Наиболее часто используемый способ программной отправки HTML-формы с помощью Javascript — это метод **submit**.
Однако у него есть (как минимум) два неожиданных поведения:

1. submit обойдет проверку формы. Это означает, что приведенная выше форма будет отправлена, даже если у нас есть обязательный атрибут, установленный для ввода электронной почты, и этот ввод пуст.

        // submit() will not take into account the required attr
        <input required name="email" id="email" type="email" >

2. если мы добавим addEventListener('submit') в форму, submit также обойдет его. Например:

        form.addEventListener('submit', e => {
          // this code will not be called when using submit()
          e.preventDefault()
          alert('Code after preventDefault called')
        })

Если вы используете **form.requestSubmit()** вместо form.submit(), форма будет отправлена только в том случае, если она действительна. Если вы оставите поле имени пустым, браузер покажет пользователю подсказку о том, что ему необходимо заполнить это поле, и форма не будет отправлена.
</details>

<details><summary><b>Расскажите о `IntersectionObserver`?</b></summary>

Intersection Observer — браузерный API, который позволяет асинхронно отслеживать пересечение элемента с его родителем или областью видимости документа (viewport). В момент пересечения можно запустить какое-либо действие, например, подгрузить дополнительные посты в ленте новостей («бесконечный скролл») или сделать «ленивую» загрузку контента.

    const lazyImages = document.querySelectorAll('.lazy-image')
    
    const callback = (entries, observer) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                console.log('Пользователь почти докрутил до картинки!')
    
                entry.target.src = entry.target.dataset.src
                observer.unobserve(entry.target)
            }
        })
    }
    
    const options = {
        // root: по умолчанию window, но можно задать любой элемент-контейнер
        rootMargin: '0px 0px 75px 0px',
        threshold: 0,
    }
    
    const observer = new IntersectionObserver(callback, options)

    lazyImages.forEach((image) => observer.observe(image))

На вход Intersection Observer принимает функцию-колбэк, которая будет выполняться при пересечении области и элементов, а также дополнительные настройки пересечения options.

**_Колбэк_** принимает два аргумента:

1) **entries** — список объектов с информацией о пересечении.

Объект содержит несколько свойств, самые полезные это:
- isIntersecting — булево значение. true если есть пересечение элемента и наблюдаемой области.
- intersectionRatio — доля пересечения от 0 до 1. Если элемент полностью в наблюдаемой области, то значение будет 1, а если наполовину, то — 0.5.
- target — сам наблюдаемый элемент для дальнейших манипуляций. Например, для добавления классов.

2) **observer** — ссылка на экземпляр наблюдателя для вызова методов прослушивания:
- observe(элемент) — запускает наблюдение за переданным элементом;
- unobserve(элемент) — убирает элемент из списка наблюдаемых;
- disconnect() — останавливает наблюдения за всеми элементами.


**_OPTIONS_** – необязательный аргумент в виде объекта с тремя свойствами:

- root — элемент, который будет областью наблюдения. Должен быть предком наблюдаемого элемента. По умолчанию — window.
- rootMargin — строка с отступами для области наблюдения.
- threshold — порог пересечения, при котором будет срабатывать колбэк. Может быть либо одним числом от 0 до 1, либо массивом значений, например [0, 0.5, 1]. По умолчанию — 0.

https://doka.guide/js/intersection-observer/
</details>

<details><summary><b>Расскажите о `URLSearchParams`?</b></summary>

URLSearchParams — это класс, предоставляющий удобное API для формирования строки поисковых параметров, которую потом можно использовать для формирования полного адреса. Все параметры в строке будут закодированы для безопасной вставки в адрес.

    const params = new URLSearchParams({ count: '10' })

    // добавление
    params.append('size', 'lg')
    console.log(params.toString())
    // 'count=10&size=lg'
    
    // удаление
    params.delete('count')
    console.log(params.toString())
    // 'size=lg'

Повторное добавление параметра с тем же именем добавит ещё одно значение с таким же именем, а получение всех возможных значений вернёт все добавленные значения:

    params.append('size', 'xl')
    console.log(params.getAll('size'))
    // ['lg', 'xl']

https://doka.guide/js/urlsearchparams/
</details>

<details><summary><b>Какие есть ограничения у `window.close()`?</b></summary>

В спецификации написано, что окно может быть закрыто с помощью close только тогда, когда оно было открыто с помощью скрипта и когда в текущей истории посещений таба находится только один документ. Такие ограничения были добавлены, для того чтобы предотвратить негативные UX-паттерны, связанные с закрытием документа.

У каждого браузера имеется собственный набор моделей поведения, связанный с window.close(). Отчасти это так из-за того, что большинство этих моделей поведения было реализовано до появления соответствующего стандарта.

В **_INTERNET EXPLORER_** вкладка или окно браузера закрывается без лишних вопросов в том случае, если для создания этой вкладки или этого окна была использована команда window.open(). Браузер не пытается удостовериться в том, что история посещений страниц вкладки содержит лишь один документ. Даже если у вкладки будет большой TravelLog, она, если открыта скриптом, просто закроется.

В **_CHROMIUM 88_** (Microsoft Edge, Google Chrome и другие браузеры) команда window.close() выполняется успешно в том случае, если у нового окна или у новой вкладки что-то записано в свойство opener, или в том случае, если стек навигации страницы содержит менее двух записей.

Код в **_SAFARI/WEBKIT_** похож на код Chromium (что неудивительно, учитывая их генеалогию). Исключением является лишь тот факт, что WebKit не уравнивает переходы по noopener-страницам с переходами, инициированными через интерфейс браузера. В результате пользователь, работая в Safari, может перемещаться по множеству страниц с одного сайта, а команда close() при этом будет работоспособна.

В браузере **_FIREFOX_**, в отличие от Chromium, та часть спецификации HTML, в которой говорится о «только одном Document», реализована корректно. Firefox вызывает функцию IsOnlyTopLevelDocumentInSHistory(), а она вызывает функцию IsEmptyOrHasEntriesForSingleTopLevelPage(), которая проверяет историю сессий. Если там больше одной записи, она уточняет, относятся ли они все к одному и тому же объекту Document. Если это так — вызов close() выполняется.

https://habr.com/ru/companies/ruvds/articles/550194/

</details>

---
