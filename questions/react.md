<h3>
  <img src="../assets/React.png" width="16" height="16" />
  <span>React:</span>
</h3>

---

1. Что такое React?
2. Перечислите особенности React?
3. Что такое Virtual DOM? Как он работает с React?
4. Для чего нужен атрибут `key` при рендере списков?
5. Что такое `PureComponent`?
6. Что такое Компонент высшего порядка (Higher-Order Component/HOC)?
7. Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?
8. Методы жизненного цикла компонента в React?
9. Стадии жизненного цикла компонента в React?

<details><summary><b>Что такое React Reconciliation?</b></summary>
Сверка - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен вычислить, нужно ли обновлять DOM. Он делает это, создавая виртуальную модель DOM и сравнивая ее с текущей моделью DOM. В этом контексте виртуальная модель DOM будет содержать новое состояние компонента.

Существует несколько общих решений алгоритмической проблемы трансформации одного дерева в другое за минимальное
количество операций. Тем не менее, даже передовые алгоритмы имеют сложность порядка O(n3), где n — это число элементов в
дереве.

Если бы мы использовали это в React, отображение 1000 элементов потребовало бы порядка миллиарда сравнений. Это слишком
дорого. Взамен, React реализует эвристический алгоритм O(n), который основывается на двух утверждениях:

- Два элемента с разными типами произведут разные деревья.
- Разработчик может указать какие дочерние элементы останутся стабильными между рендерами с помощью пропа key.

Чтобы провести различие между деревом, нам сначала нужно иметь возможность различать два узла. Рассматриваются три
разных случая.

**1. Элементы различных типов**

Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.
При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают componentWillUnmount(). При построении
нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают UNSAFE_componentWillMount(), а затем
componentDidMount(). Любое состояние, связанное со старым деревом, теряется.

Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится.

**2. DOM-элементы одного типа**

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих
элементов DOM-узел и обновляет только изменённые атрибуты.

**3. Компоненты одного типа**

Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React
обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает
UNSAFE_componentWillReceiveProps(), UNSAFE_componentWillUpdate и componentDidUpdate() на базовом экземпляре.

**Рекурсия по дочерним элементам**

По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и
создаёт мутацию, когда находит отличие.

При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например,
преобразование между этими деревьями работает плохо:

    <ul>
        <li>Санкт-Петербург</li>
        <li>Москва</li>
    </ul>
    
    <ul>
        <li>Ростов-на-Дону</li>
        <li>Санкт-Петербург</li>
        <li>Москва</li>
    </ul>

React, вместо того чтобы оставить Санкт-Петербург и Москва нетронутыми, будет мутировать каждого потомка. Эта
неэффективность может стать проблемой.

Для решения этой проблемы React поддерживает атрибут **_key_**. Когда у дочерних элементов есть ключи, React
воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.

https://ru.legacy.reactjs.org/docs/reconciliation.html
</details>

11. Что такое портал (`Portal`)?
12. Что такое контекст (`Context`)?
13. Что такое React хуки (Hooks)?
14. Что Такое `JSX`?
15. Разница между состоянием(`state`) и пропсами(`props`)?
16. Что такое React Fiber?
17. Что такое фрагмент (`Fragment`)? Почему фрагмент лучше, чем `div`?

<details><summary><b>Что такое синтетические события в React?</b></summary>

**SyntheticEvent** - это кроссбраузерная обертка для нативных событий браузера. Этот API аналогичен браузерному, включая
stopPropagation() и preventDefault(), но работает одинаково во всех браузерах.
</details>
<details><summary><b>Что такое React-ссылка (`ref`)? Как создать ссылку?</b></summary>
Refs предоставляет способ доступа к DOM-узлам или React-элементам, созданным в методе render().

Есть несколько хороших примеров использования ссылок:

- Управление фокусом, выделение текста или воспроизведение медиаресурсами.
- Выполнение анимаций в императивном подходе.
- Интеграция со сторонними библиотеками, взаимодействующие с DOM.

Частой ошибкой разработчиков React является использование useState для каждого изменяемого значения, которое нужно
сохранить между процессами рендера. useState — хорошее решение, если выводимый результат зависит от значения, в
противном случае лучше применять useRef.

Значение ссылки отличается в зависимости от типа узла:

- Когда атрибут ref используется в HTML-элементе, ref, созданный в конструкторе с помощью React.createRef(), получает
  базовый элемент DOM в качестве своего свойства current.
- Когда атрибут ref используется на пользовательском классовом компоненте, объектref получает примонтированный экземпляр
  компонента в качестве своего свойства current.
- Вы не можете использовать атрибут ref в функциональных компонентах, потому что у них не может быть экземпляров.

Создать ссылку можно двумя способами:

- createRef() используется в классовых компонентах и привязываются к элементу с помощью атрибута ref. Получить доступ к
  значению можно обратившись к атрибуту current. При использовании в функциональных компонентах будет создаваться на
  каждый рендер, что влияет на оптимизацию приложения.
- Поэтому, в функциональных приложениях лучше пользоваться хуком useRef(), который при каждом повторном рендере
  сохраняет ссылку на объект ref, созданный при первом монтировании.

[Ссылки в React] https://habr.com/ru/articles/540442/
</details>

20. Разница между теневым (Shadow) и виртуальным (Virtual) DOM?
21. Назовите преимущества использования React?

<details><summary><b>Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?</b></summary>

Условный рендеринг (conditional rendering) означает отображение элементов в пользовательском интерфейсе только в том
случае, если выполняется определенное условие, в противном случае элементы скроются.

Для условного рендеринга (conditional rendering) можно использовать обычные if или тернарные операторы. Кроме того, в
JSX можно встраивать любое выражение посредством оборачивания его в фигурные скобки, а также совместно с логическим
оператором && (короткие вычисления).

<code>

    <h1>Привет!</h1>
    {
    messages.length > 0 && !isLogin
        ? (<h2>
            У вас {messages.length} непрочитанных сообщений.
        </h2>)
        : (<h2>
            У вас нет непрочитанных сообщений.
        </h2>)
    }

</code>
</details>

<details><summary><b>Что такое компонент-переключатель (Switching Component)?</b></summary>

Компонент-переключатель (switching component) - это компонент, который рендерит один из нескольких компонентов. Для
получения значений пропов для компонентов необходимо использовать объект.

Пример компонента-переключателя, отображающего разные страницы на основе пропа page:

    import HomePage from './HomePage'
    import AboutPage from './AboutPage'
    import ServicesPage from './ServicesPage'
    import ContactPage from './ContactPage'
    
    const PAGES = {
        home: HomePage,
        about: AboutPage,
        services: ServicesPage,
        contact: ContactPage
    }
    
    const Page = (props) => {
        const CurrentPage = PAGES[props.page] || HomePage
    
        return <CurrentPage {...props} />
    }
    
    // ключи объекта `PAGES` могут быть использованы в `propTypes`
    Page.propTypes = {
        page: PropTypes.oneOf(Object.keys(PAGES)).isRequired
    }

</details>

<details><summary><b>Разница между `React` и `ReactDOM`?</b></summary>
React и ReactDOM совсем недавно были разделены на две разные библиотеки. До версии 0.14 вся функциональность ReactDOM была частью React. Это может стать источником путаницы, поскольку в любой слегка устаревшей документации не упоминается различие React и ReactDOM.

Как следует из названия, ReactDOM — это связующее звено между React и DOM. Часто вы будете использовать его только для
одной цели: монтирования с помощью ReactDOM.render(). Еще одна полезная функция ReactDOM — ReactDOM.findDOMNode(),
которую вы можете использовать для получения прямого доступа к элементу DOM. (Это то, что вам следует использовать с
осторожностью в приложениях React, но это может быть необходимо.) Если ваше приложение «изоморфно», вы также должны
использовать ReactDOM.renderToString() в своем внутреннем коде.

Для всего остального есть React. Вы используете React для определения и создания ваших элементов, для перехватчиков
жизненного цикла и т. д., то есть для внутренней части приложения React (React.createElement(), React.Component,
React.Children).
</details>

<details><summary><b>Разница между компонентом и контейнером?</b></summary>

**Презентационныe компоненты:**

- Интересует как части выглядят.
- Могут содержать как презентационный, так и контейнеры-компоненты внутри, и обычно содержат некоторую собственную
  разметку DOM и стили.
- Часто дает возможность обратиться через this.props.children.
- Не зависит от остальной части приложения, таких как действия Flux или сторов.
- Не используется для загрузки или изменения данных.
- Получает данные и функции обратного вызова только через props.
- Редко хранит свое состояние (обычно они относятся к интерфейсу, чем к другим данным).
- Написаны как функциональные компоненты до тех пор пока не нуждаются в состоянии, использовании в жизненном цикле или
  оптимизации производительности.
- Например, Page, Sidebar, Story, UserInfo, List.

**Компоненты-контейнеры:**

- Интересует как части работают.
- Могут содержать как презентационный, так и контейнеры-компоненты** внутри, но обычно не имеют разметки DOM, за
  исключение некоторых блоков div в качестве обертки, и не имеют никаких стилей.
- Содержат данные или поведение презентационных или других компонентов-контейнеров.
- Вызывают действия Flux и передают их в качестве функций обратного вызова в презентационные компоненты.
- Часто имеют состояние и служат источником данных.
- Чаще создаются с использованием компонентов высокого порядка, таких как connect() в React Redux, createContainer() в
  Relay или Container.create() в Flux Utils, чем пишутся вручную.
- Например, UserPage, FollowersSidebar, StoryContainer, FollowedUserList.

</details>

<details><summary><b>Как React обрабатывает, или ограничивает использование пропсов определенного типа?</b></summary>

PropTypes - хороший способ перехвата ошибок, связанных с неправильными типами props.

PropTypes позволяет помечать пропы как обязательные или определять их значения по умолчанию.

    import React from 'react'
    import PropTypes from 'prop-types'

    const Person = (props) => (
        <div>
            <h1>{props.firstName} {props.lastName}</h1>
            {props.country ? <p>Страна: {props.country}</p> : null}
        </div>
    )

    Person.propTypes = {
        firstName: PropTypes.string,
        lastName: PropTypes.string,
        country: PropTypes.string
    }

    export default Person

PropTypes определяет тип пропа. Каждый раз, когда через проп передается какое-либо значение, оно проверяется на
правильный тип. Если будет обнаружен неправильный тип, в консоль будет выведено сообщение об ошибке.
</details>

27. Что такое строгий режим в React? Его преимущества?

<details><summary><b>Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?</b></summary>

В React пропы передаются в одном направлении, сверху вниз, от родительского компонента к дочернему, и последовательно.
При наличии незначительного количества пропов или потомков - это не является проблемой. Однако при росте приложения для
того, чтобы передать пропы с верхнего уровня приложения компонентам, находящимся на 3 или 4 уровне вложенности, нам
приходится передавать одни и те же пропы на каждом уровне дерева компонентов. Это называется бурением пропов (prop
drilling).

Context API

Контекст решает некоторые проблемы, связанные с "бурением". Он позволяет компонентам получать данные на любом уровне без
их передачи в виде пропов. Передаваемыми данными может быть что угодно: состояние, функция, объект и т.д. Эти данные
доступны любым вложенным компонентам в пределах области видимости контекста.

    import React from "react"
    import ReactDOM from "react-dom"

    // создаем контекст
    const NumberContext = React.createContext() // он возвращает объект с двумя значениями   { Provider, Consumer }

    function App() {
        // используем провайдер для предоставления потомкам доступа к данным
        return (
            <NumberContext.Provider value={10}>
                <div>
                  <Display />
                </div>
            </NumberContext.Provider>
        )
    }

    function Display() {
        // извлекаем значение из контекста
        const value = useContext(NumberContext)

        return <div>Ответ: {value}.</div>
    }

</details>

<details><summary><b>Что такое «опрос» (Polling)? Как его реализовать в React?</summary></b>
Подход, когда раз в n секунд опрашивается сторонний сервис, называется polling.

Использование setInterval() в React-компонентах позволяет выполнять функцию или другой код через определенные промежутки
времени.
</details>
<details><summary><b>Разница между элементом и компонентом?</b></summary>
Элемент - это обычный объект, описывающий, что мы хотим увидеть на экране в терминах узлов и других частей DOM. Элементы могут содержать другие элементы в своих свойствах. Создавать элементы в React легко. Однако после создания, элемент не подлежит изменению.

Объектное представление React-элемента выглядит так:

    const element = React.createElement(
        'div',
        { id: 'login-btn' },
        'Войти'
    )

Функция React.createElement возвращает такой объект:

    {
        type: 'div',
        props: {
            children: 'Войти',
            id: 'login-btn'
        }
    }

Данный объект рендерится с помощью ReactDOM.render():

    <div id='login-btn'>Login</div>

В отличие от элемента, компонент может определяться по-разному. Он может быть классом с методом render (классовый
компонент) или простой функцией (функциональный компонент). В любом случае компонент принимает свойства (пропы, props от
properties) на вход и возвращает JSX:

    const Button = ({ onLogin }) =>
        <div id={'login-btn'} onClick={onLogin}>Войти</div>

JSX транспилируется (преобразуется) в функцию React.createElement:

    const Button = ({ onLogin }) => React.createElement(
        'div',
        { id: 'login-btn', onClick: onLogin },
        'Войти'
    )

</details>

<details><summary><b>Что такое `ReactDOMServer`?</b></summary>
Объект ReactDOMServer позволяет отрендерить компоненты в статическую разметку. В основном, он используется на Node-сервере.

Рендеринг на стороне сервера (server-side rendering, SSR) - это техника, позволяющая отрисовывать клиентские
одностраничные приложения (single page application, SPA) на сервере и отправлять их клиенту в виде готовой разметки. Это
делает динамические компоненты статическими.

Это повышает скорость рендеринга страниц, что улучшает пользовательский опыт.

Это улучшает поисковую оптимизацию (search engine optimization, SEO), облегчая индексацию страниц поисковыми роботами.

Это повышает доступность метаданных (изображения, заголовок, описание и т.д.), что позволяет пользователям легко
делиться приложением в социальных сетях.
</details>

32. Что такое предохранители (Error Boundaries)?
33. Что такое «ленивая» (Lazy) функция?

<details><summary><b>Разница между рендерингом и монтированием?</b></summary>

**_Рендеринг_** - это функция или метод render, вызываемый компонентом, возвращающие инструкции для создания DOM. Метод
render вызывается при каждом рендеринге компонента. Обновление компонента происходит при изменении его state или props.

**_Монтирование_** - это первый рендеринг компонента и построение первоначальной объектной модели документа (
виртуального DOM). Монтирование компонента означает встраивание создаваемых им элементов в браузерный DOM.

_Повторный рендеринг_ - это повторный вызов функции для получения информации об уже смонтированном компоненте.
</details>

35. Что такое `сhildren`?

<details><summary><b>Что такое события указателя (Pointer Events)?</b></summary>

События указателя (Pointer events) – это современный способ обработки ввода с помощью различных указывающих устройств,
таких как мышь, перо/стилус, сенсорный экран и так далее.
Эти события поддерживаются современными браузерами и позволяют разработчикам писать код, который последовательно и
предсказуемо реагирует на взаимодействие пользователя со страницей, независимо от типа используемого устройства ввода.

Некоторые из наиболее часто используемых событий указателя включают в себя:

- pointerdown:событие срабатывает, когда пользователь нажимает указатель на элемент.
- pointerup: событие срабатывает, когда пользователь отпускает указатель с элемента.
- pointermove: событие срабатывает, когда пользователь наводит указатель на элемент.
- pointerover: событие срабатывает, когда пользователь наводит указатель на элемент.
- pointerout: событие срабатывает, когда пользователь перемещает указатель за пределы элемента.
- pointercancel: событие, возникающее, когда взаимодействие пользователя с указателем прерывается (например, при
  переключении на другое приложение).

https://bestprogrammer.ru/programmirovanie-i-razrabotka/sobytiya-ukazatelya-v-javascript-dom
</details>

<details><summary><b>Что такое инверсия наследования (Inheritance Inversion)?</b></summary>

Инверсия наследования (inheritance inversion) - это HOC, который выглядит следующим образом:

    const inheritanceInversionHOC = (WrappedComponent) => {
        return class extends WrappedComponent {
            render() {
                return super.render()
            }
        }
    }

Возвращенный класс HOC (Enhancer) расширяет WrappedComponent. Это называется инверсией наследования, потому что вместо
того, чтобы WrappedComponent расширял некоторый класс Enhancer, Enhancer пассивно расширяет его. Таким образом, их
отношения кажутся перевернутыми.

Инверсия наследования предоставляет HOC доступ к экземпляру WrappedComponent. Это означает, что мы можем использовать
state, props, методы жизненного цикла и даже метод render данного компонента.

Случаи использования

- Перехват рендеринга.
- Управление состоянием.

Кроме того, существует еще одна разновидность HOC – Props Proxy. Привер:

    function HOC(WrappedComponent) {
        return class Test extends Component {
            render() {
                const newProps = {
                    title: 'Test Component',
                    showFeatureX: false,
                    showFeatureY: true,
                };
                return <WrappedComponent {...this.props} {...newProps} />;
            }
        };
    }

https://www.freecodecamp.org/news/how-to-develop-your-react-superpowers-with-the-hoc-pattern-61293651d59/
</details>

<details><summary><b>Как в React реализовать двустороннее связывание данных?</b></summary>

Двусторонняя привязка данных обеспечивает двунаправленный поток данных. Это означает, что изменения в пользовательском
интерфейсе автоматически обновляют состояние компонента, а изменения состояния автоматически обновляют пользовательский
интерфейс. В React двусторонняя привязка данных достигается с помощью контролируемых компонентов.

    import React, { useState } from 'react'

    function App(){
        const [name, setName] = useState('')
    
        const handleChange = (e) => {
            setName(e.target.value)
        }
    
        return (
            <div>
                <input onChange={handleChange} value={name} />
                <h1>{name}</h1>
            </div>
        )
    }

    export default App

Ввод текста в поле запускает обработчик onChange(), который вызывает метод setName, обновляющий свойство name.
Обновление данного свойства приводит к повторному рендерингу компонента UserInput.

https://handsontable.com/blog/understanding-data-binding-in-react#:~:text=Two%2Dway%20data%20binding%20allows,is%20achieved%20using%20controlled%20components
.
</details>

39. Разница между классовым и функциональным компонентами?

<details><summary><b>Разница между `useEffect()` и `componentDidMount()`?</b></summary>
В React при использовании классовых компонентов мы получаем доступ к методам жизненного цикла (таким как componentDidMount, componentDidUpdate и т.д.). В функциональных компонентах альтернативой методам жизненного цикла являются хуки.

componentDidMount() и useEffect() запускаются после монтирования компонента. Тем не менее, useEffect() вызывается после
отображения на экране результатов рендеринга. Это означает, что мы можем получить мерцание (flicker) в случае, когда
необходимо прочитать DOM и синхронно обновить состояние для получения нового UI.

useLayoutEffect() был спроектирован специально для таких случаев. Он вызывается перед отображением на экране результатов
рендеринга, т.е. синхронно. Поэтому useLayoutEffect(fn, []) ближе к componentDidMount(), чем useEffect(fn, []), по
времени выполнения.
</details>

41. Преимущества хуков?
42. Недостатки хуков?

<details><summary><b>Правила (ограничения) использования хуков?</b></summary>
    Хуки имеют ряд ограничений при определении и использовании:

Хуки вызываются только на верхнем уровне (top-level) компонента.
Не вызывайте хуки внутри циклов, условных операторов или вложенных функций. Вместо этого всегда используйте хуки только
внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются
в одинаковой последовательности при каждом рендере компонента.

Хуки можно вызывать только из функциональных компонентов React, либо из других хуков. Но их нельзя вызывать из
классов-компонентов.
Следуя этому правилу, можно гарантировать, что вся логика состояния компонента чётко видна из исходного кода.
</details>

<details><summary><b>Что такое поднятие состояния вверх (Lifting State Up)?</b></summary>

Одним из способов распределения состояния между двумя компонентами является определение состояния в их родительском
компоненте. Такой подход называется подъемом состояния (state lifting). Изменения общего состояния незамедлительно
отражаются на соответствующих компонентах.

https://ru.legacy.reactjs.org/docs/lifting-state-up.html
</details>

45. Что делает метод `shouldComponentUpdate`?

<details><summary><b>Разница между `createElement()` и `cloneElement()`?</b></summary>

**React.createElement()** используется для создания элементов. Всякий раз, когда мы пишем код в JSX, JSX преобразует его
в React.createElement(). Метод createElement использовать не рекомендуется, поскольку его очень сложно поддерживать и
отлаживать. Нам приходится вызывать метод React.createElement() каждый раз для создания элемента React, даже если это
просто тег span без атрибутов.

**React.cloneElement()** используется, когда родительский компонент хочет добавить или изменить props своих дочерних
элементов. Функция React.cloneElement() создает клон данного элемента, и мы также можем передавать в функцию реквизиты и
дочерние элементы.
</details>

<details><summary><b>Что такое `useReducer()`?</b></summary>

useReducer - это хук, принимающий функцию-редуктор и начальное состояние приложения в качестве параметров и возвращающий
текущее состояние и диспетчер (dispatcher) для отправки (dispatch) операций для обновления состояния.

Несмотря на то, что useState - это базовый хук, а useReducer - продвинутый, на самом деле useState() реализован с
помощью useReducer(). Это означает, что useReducer() - это примитив, который может использоваться во всех случаях
использования useState(). Редуктор - мощный инструмент, который может использоваться в самых разных сценариях.

    import React, { useReducer } from 'react'

    const initialState = 0

    const reducer = (state, action) => {
        switch (action) {
            case 'increment': return state + 1
            case 'decrement': return state - 1
            case 'reset': return 0
            default: return state
        }
    }

    const ReducerExample = () => {
        const [count, dispatch] = useReducer(reducer, initialState)

        return (
            <div>
                {count}
                <button onClick={() => dispatch('increment')}>+</button>
                <button onClick={() => dispatch('decrement')}>-</button>
                <button onClick={() => dispatch('reset')}>0</button>
            </div>
        )
    }

    export default ReducerExample

Сначала мы определяем начальное состояние и редуктор. Затем передаем их в useReducer(). Хук возвращает текущее значение
состояния и диспетчер, который используется для обновления состояния. Когда пользователь нажимает на кнопку, происходит
отправка определенной операции в редуктор, который обновляет счетчик на основе операции. Мы может определять столько
операций, сколько требуется нашему приложению.
</details>
<details><summary><b>Как реализовать однократное выполнение операции при начальном рендеринге?</b></summary>

Для этого можно использовать метод жизненного цикла componentDidMount в классовом компоненте:

    class Homepage extends React.Component {
        componentDidMount() {
            trackPageView('Homepage')
        }

        render() {
            return <div>Домашняя страница</div>
        }
    }

Любые операции, определенные в componentDidMount(), будут выполнены только один раз при монтировании компонента.

Аналогичный функционал можно реализовать с помощью хука useEffect с пустым массивом зависимостей:

    const Homepage = () => {
        useEffect(() => {
            trackPageView('Homepage')
        }, [])

        return <div>Домашняя страница</div>
    }

Второй параметр контролирует запуск эффекта:

- Если второй параметр отсутствует, эффект выполняется при каждом рендеринге.
- Если массив содержит переменные, то эффект запускается при монтировании компонента, а также при каждом изменении любой
  переменной.
- Если массив является пустым, то эффект будет запущен только один раз при монтировании компонента. В этом случае
  функционал будет аналогичен вызову componentDidMount() в классовом компоненте.

</details>

<details><summary><b>Что такое распределенный компонент?</b></summary>
Распределенный компонент (shared component) - это разновидность компонента, который управляет своим внутренним состоянием, а логику рендеринга делегирует другому компоненту. Таким образом, место определения компонента отделяется от места его реализации. Это предоставляет возможность защитить специфическую логику от остального приложения, предоставляя "чистый" и выразительный API для потребления (consume) компонентом.

Распределенные компоненты конструируются таким образом, чтобы оперировать набором данных, которые передаются через
дочерние компоненты вместо пропов. Под капотом они используются низкоуровневое API, такое как React.children.map() и
React.cloneElement(). С помощью этих методов компонент получает возможность к "самовыражению" способом, обеспечивающим
возможность применения паттернов, связанных с композицией и масштабируемостью.

    function App() {
        return (
            <Menu>
                <MenuButton>
                    Операции <span aria-hidden>▾</span>
                </MenuButton>
                <MenuList>
                    <MenuItem onSelect={() => alert('Download')}>Скачать</MenuItem>
                    <MenuItem onSelect={() => alert('Copy')}>Копировать</MenuItem>
                    <MenuItem onSelect={() => alert('Delete')}>Удалить</MenuItem>
                </MenuList>
            </Menu>
        )
    }

Компонент <Menu> содержит явно определенное совместное состояние. Компоненты <MenuButton>, <MenuList> и <MenuItem> имеют
доступ к этому состоянию, все манипуляции осуществляются в явном виде.

</details>

<details><summary><b>Расскажите о хуках `useCallback()`, `useMemo()`, `useImperativeHandle()`, `useLayoutEffect()`?</b></summary>

Хук _**useCallback**_ может использоваться для оптимизации рендеринга функциональных компонентов. Он возвращает
мемоизированную версию колбека. Это означает, что такой колбек обновляется только при изменении его зависимостей. Это
может быть полезным при передаче колбеков оптимизированным (например, с помощью метода shouldComponentUpdate) дочерним
компонентам.

Хук _**useMemo**_ может использоваться для оптимизации вычислений, производимых в функциональных компонентах. useMemo()
похож на useCallback(), за исключением того, что он принимает любые значения, а не только функции. Он принимает функцию,
возвращающую значение, и массив зависимостей. Значение, возвращенное функцией, вычисляется повторно только при изменении
зависимостей.

_**useImperativeHandle**_ - это перехватчик React, который позволяет родительскому компоненту получать доступ к функциям
и атрибутам экземпляра дочернего компонента. Это полезно в ситуациях, когда родительский компонент должен
взаимодействовать с дочерним компонентом определенным образом, например, при сбросе состояния формы или работой с
модальным окном.

Первым аргументом он принимает ref, который прилетел в функциональный компонент извне. Вторым аргументом принимает
функцию (init), которая возвращает объект, что будет записан в ref. А третий аргумент (deps) - это массив зависимостей.

    import React, { useRef, useImperativeHandle, forwardRef } from 'react';
    
    const ChildComponent = forwardRef((props, ref) => {
        const inputRef = useRef(null);
        
        // expose the setInputValue function to the parent component
        useImperativeHandle(ref, () => ({
                setInputValue: (value) => {
                    inputRef.current.value = value;
                },
        }));
        
        return <input type="text" ref={inputRef} />;
    });
        
    function ParentComponent() {
        const childRef = useRef(null);
        
        const handleClick = () => {
            // set the input value of the child component
            childRef.current.setInputValue('Hello, world!');
        };
        
        return (
            <div>
                <button onClick={handleClick}>Set input value</button>
                <ChildComponent ref={childRef} />
            </div>
        );
    }

Хук _**useLayoutEffect**_ запускается после выполнения всех манипуляций с DOM, но до его отрисовки браузером. Это может
быть полезным для получения дополнительной информации из DOM (например, получение величины прокрутки или стилей
элемента) и использования этой информации для корректировки DOM или запуска повторного рендеринга путем обновления
состояния.

useLayoutEffect() против useEffect()

- useLayoutEffect: нам нужно внести незаметные для пользователя изменения в DOM.
- useEffect: нам не нужно взаимодействовать с DOM, или наши манипуляции с ним незаметны для пользователя (в большинстве
  случаев так и есть).

Хук _**useDebugValue**_ может использоваться для отображения подписей к пользовательским хукам в React DevTools.

    function useFriendStatus(friendID) {
        const [isOnline, setIsOnline] = useState(null)

        // ...

        // добавляем хуку подпись, отображаемую в инструментах разработчика
        // это может выглядеть как `FriendStatus: В сети`
        useDebugValue(isOnline ? 'В сети' : 'Не в сети')

        return isOnline
    }

https://youtu.be/AyaAz42Yvi4?si=SIwhuov-B50WSlER
https://youtu.be/zpEyAOkytkU?si=ZuXomab_lYIUPKt2
https://youtu.be/_QJ6v7mqL84?si=_j5SWVVrJ3ytlhrE

[useImperativeHandle] https://vc.ru/u/1389654-machine-learning/670964-davayte-uglubimsya-v-react-hooks-react-16-8#:~:text=%D1%8D%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BB%D0%B8%20useEffect.-,useImperativeHandle,-()
</details>

54. Как отрендерить HTML код в React-компоненте?
52. Зачем в `setState()` нужно передавать функцию?

<details><summary><b>Для чего предназначен метод `registerServiceWorker()` в React?</b></summary>

React создает сервис-воркера (service worker) без необходимости предварительной настройки из коробки (при использовании
шаблона pwa в create-react-app). Сервис-воркер - это веб-API, позволяющий записывать файлы приложения в кеш и возвращать
их из него при отсутствии подключения к сети или медленном соединении, что сильно улучшает пользовательский опыт,
обеспечивая возможность работы приложения в режиме офлайн. Сервис-воркер - это своего рода прокси для HTTP-запросов.

    import React from 'react'
    import ReactDOM from 'react-dom'
    import App from './App'
    import registerServiceWorker from './registerServiceWorker'
    
    ReactDOM.render(<App />, document.getElementById('root'))
    registerServiceWorker()
</details>

<details><summary><b>Чем React Router отличается от обычной маршрутизации?</b></summary>
В React существует лишь один HTML-файл (index.html). Когда пользователь переходит на новую страницу, вместо получения данных от сервера, роутер возвращает тот или иной компонент. У пользователя создается впечатление перемещения между страницами, но, в действительности, компоненты приложения являются не более чем разными представлениями одной страницы.

_Как React это делает?_

Router "заглядывает" в History каждого компонента и при наличии изменений в истории, компонент перерисовывается. До React Router 4 нам приходилось устанавливать значение History вручную. Однако, начиная с React Router 4, большая часть работы, связанной с маршрутизацией, автоматически выполняется компонентом <BrowserRouter> (на стороне клиента).
</details>

<details><summary><b>Какие хуки были добавлены в React Router версии 5?</b></summary>

**_useHistory_**
- Предоставляет доступ к пропу history.
- Ссылается на пакет-зависимость history, используемую роутером.
- Основное назначение состоит в программной маршрутизации с помощью таких методов, как push, replace и др.

**_useLocation_**
- Предоставляет доступ к пропу location.
- Похож на window.location, но доступен в любом месте, поскольку является представлением состояния и текущей локации роутера.
- Основное назначение состоит в доступе к параметрам строки запроса (query params) и полному адресу страницы.

**_useParams_**
- Предоставляет доступ к параметрам поисковой строки в URL.
- Раньше это было возможно только с помощью match.params.

**_useRouteMatch_**
- Предоставляет доступ к объекту match.
- Если используется без аргументов, возвращает ближайшее совпадение в компоненте или его предках.
- Основное назначение состоит в создании вложенных маршрутов.

  
    import { useRouteMatch, Route } from 'react-router-dom'

    function Auth() {
    const match = useRouteMatch()

      return (
        <>
          <Route path={`${match.url}/login`}>
            <Login />
          </Route>
          <Route path={`${match.url}/register`}>
            <Register />
          </Route>
        </>
      )
    }
  
useRouteMatch() также может использоваться для поиска совпадения без рендеринга маршрута. Для этого ему необходимо передать аргумент location.
</details>

<details><summary><b>Как передавать пропсы в React Router?</b></summary>
Компонент с пропом render() принимает функцию, возвращающую React-элемент, и вызывает ее вместо реализации собственной логики рендеринга. Данная техника используется для распределения кода между компонентами с помощью пропа, значением которого является функция.

    import React from "react"
    import { render } from "react-dom"
    import { Greeting } from "./components/Greeting.js"

    import { BrowserRouter as Router, Route, Link } from "react-router-dom"

    const styles = {
      fontFamily: "sans-serif",
      textAlign: "center"
    }

    const App = () => (
      <div style={styles}>
        <h2>Нажмите на ссылку ниже, чтобы перейти на другую страницу</h2>
        <Link to="/greeting/народ">Перейти к /greeting/народ</Link>
      </div>
    )

    const RouterExample = () => (
      <Router>
        <div>
          <ul>
            <li>
              <Link to="/">Главная</Link>
            </li>
          </ul>

          <hr />

          <Route exact path="/" component={App} />
          <Route
              path="/greeting/:name"
              render={(props) => <Greeting text="Привет, " {...props} />}
          />
        </div>
      </Router>
    )

    render(<RouterExample />, document.getElementById("root"))
</details>

<details><summary><b>Что такое Reselect и как он работает?</b></summary>

Reselect - это библиотека селекторов (для Redux), которая использует концепцию мемоизации.

Reselect сохраняет копию входных/выходных данных последнего вызова и производит повторные вычисления только при изменении этих данных. Если передаются одни и те же данные, Reselect возвращает результат из кеша. Мемоизация и кеширование являются полностью настраиваемыми.

_Пример:_

    import { createSelector } from 'reselect'
    
    const selectShopItems = state => state.shop.items
    const selectTaxPercent = state => state.shop.taxPercent
    
    const selectSubtotal = createSelector(
      selectShopItems, 
      items =>  items.reduce((subtotal, item) => subtotal + item.value, 0)
    )
    
    const selectTax = createSelector(
      selectSubtotal,
      selectTaxPercent,
      (subtotal, taxPercent) => subtotal * (taxPercent / 100)
    )
    
    const selectTotal = createSelector(
      [selectSubtotal, selectTax],
      (subtotal, tax) => ({ total: subtotal + tax })
    )
    
    const exampleState = {
      shop: {
        taxPercent: 8,
        items: [
          { name: 'apple', value: 1.2 },
          { name: 'orange', value: 0.95 }
        ]
      }
    }
    
    console.log(selectSubtotal(exampleState)) // 2.15
    console.log(selectTax(exampleState)) // 0.172
    console.log(selectTotal(exampleState)) // { total: 2.322 }

_Разница Reselect и useMemo/useCallback:_
- Reselect логично использовать для глобальной мемоизации - когда одно и тоже мемоизированное значение нужно использовать в разных компонентах(контейнерах) программы. Поэтому реселект используют совместно с редаксом, т.к. редакс - это состояние всего приложения.
- useMemo и useCallback - есть смысл использовать для мемоизации данных которые вычисляются для одного конкретного компонента (или его детей) и нигде больше не нужны.

[Когда стоит использовать createSelector] https://www.youtube.com/watch?v=qWzxwzcjttk&t=215s&ab_channel=%D0%90%D0%B9%D0%A2%D0%B8%D0%A1%D0%B8%D0%BD%D1%8F%D0%BA
</details>

<details><summary><b>Назовите основную цель React Fiber?</b></summary>
React Fiber — прогрессивная реализация ключевого алгоритма React. Это кульминационное достижение двухгодичных исследований команды разработчиков React.

Цель Fiber в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.

Текущая реализация обходит всё дерево рекурсивно и вызывает все рендер-функции в рамках одно тика event loop js.

Будущая реализация React Fiber может откладывать вызовы функции render на потом, появляется некоторая ассинхронность.

Основная цель Fiber – предоставить алгоритмы планировщика и в частности нужно уметь:
- ставить какую-то работу на паузу, чтобы вернуться к ней позже;
- расставлять приоритеты по задачам;
- переиспользовать результаты предыдущей работы;
- прерывать работу, если она больше не нужна.

Для этого процесс построения Virtual DOM должен быть разбит на маленькие участки, которые можно было бы запускать, останавливать или приоритезировать => концепция "unit of work".

</details>

<details><summary><b>Какие типы данных может возвращать `render`?</b></summary>

Метод render может возвращать следующие типы данных:

- React-элементы: элементы, преобразуемые в узлы DOM. Они включают в себя HTML-элементы, такие как <div> и пользовательские элементы.
- Массивы и фрагменты: элементы, представляющие собой обертки для нескольких дочерних элементов.
- Порталы: позволяют рендерить дочерние элементы в другом поддереве DOM.
- Строки и числа: встраиваются в DOM в виде текстовых узлов.
- Логические значения и null: не отображаются на экране, используются для условного рендеринга.
</details>

60. Разница между `memo` и `useMemo`?
<details><summary><b>Что такое синтетические события (SyntheticEvent) в React?</b></summary>
SyntheticEvent это обёртка над нативными событиями. SyntheticEvent является частью системы событий React.
Ваши обработчики событий получают экземпляр SyntheticEvent, это кроссбраузерная обёртка над нативным экземпляром события. У неё такой же интерфейс, как и у нативного события, включая методы stopPropagation() и preventDefault(). Эта обёртка помогает событиям работать одинаково во всех браузерах.

Еcли всё-таки нужно получить нативное браузерное событие, следует обратиться к атрибуту nativeEvent. Синтетические события отличаются от нативных событий браузера и непосредственно не связаны с ними.

</details>

62. Является ли React реактивным?
<details><summary><b>Техники оптимизации перфоманса React?</b></summary>

**1. Использование React.memo (HOC, а не хук)**

Обернув компонент в React.memo, вы обеспечите его повторный рендеринг только при изменении его пропсов. Это особенно полезно при работе со сложными компонентами, которые требуют больших затрат на рендеринг.

**2. Оптимизация обработчиков событий с помощью useCallback**

Используя хук useCallback, можно мемоизировать обработчики событий, обеспечивая таким образом их изменение только при изменении зависимостей, указанных в массиве зависимостей. Это предотвращает ненужные повторные рендеринги дочерних компонентов, которые зависят от мемоизированных обработчиков событий.

**3. Виртуализация длинных списков с помощью react-window** 

Важно оптимизировать производительность рендеринга длинных списков и таблиц. С помощью react-window можно эффективно отрендерить большой список, и при этом будут отображаться только видимые элементы, а количество создаваемых и обновляемых элементов DOM сократится. Эта техника, известная как “оконное управление” (“windowing”) или “виртуализация”, способна значительно повысить производительность.

**4. Ленивая загрузка компонентов с помощью React.lazy и Suspense**
   
Ленивая загрузка — это техника оптимизации, которая откладывает загрузку некритичных компонентов до тех пор, пока они не понадобятся. С помощью React.lazy и Suspense можно легко реализовать ленивую загрузку для компонентов. Это позволит значительно улучшить время начальной загрузки приложения за счет уменьшения количества JavaScript, который необходимо загрузить и распарсить.

    import React, { lazy, Suspense } from 'react'
    const LazyLoadedComponent = lazy(() => import('./LazyLoadedComponent'))

    const App: React.FC = () => {
      return (
        <div>
          <Suspense fallback={<div>Loading...</div>}>
            <LazyLoadedComponent />
          </Suspense>
        </div>
      )
    }

**5. Использование API React.Profiler для выявления узких мест производительности**

API для работы сReact.Profiler позволяет измерять производительность компонентов путем сбора информации о тайминге по каждой фазе рендеринга.

Используя компонент Profiler, можно определить узкие места в производительности и соответствующим образом оптимизировать приложение.

**6. Использование троттлинга и дебаунсинга для обработчиков ввода**

Применяя эти техники к обработчикам ввода, можно сократить количество вызовов функций и повысить производительность, особенно при решении таких задач, как получение данных из API и фильтрация большого набора данных.


</details>

64. Лучшие практики безопасности в React?

<details><summary><b>Мемоизация в React</b></summary>
Одной из наиболее важных концепций, которую необходимо понять для оптимизации React, является мемоизация. Мемоизация — это процесс кэширования результатов работы функции и возврата кэша при последующих запросах.

memo по умолчанию предотвратит повторный рендеринг компонента. Он будет перерисовывать компонент только в том случае,
если внутреннее состояние или проп изменяются. Сравнение происходит поверхностно. Рассмотрим такой пример.

При сравнении пропсов, чтобы определить, должен ли компонент обновляться, memo поверхностно сравнивает пропсы. Можно
представить поверхностное сравнение, как строгое сравнении JS (===) для каждого prevProp и каждого newProp. Если все
возвращают true, повторный рендеринг не запускается, если все возвращают false, то рендеринг запускается. Т.е. значения
типов boolean, string, number, undefined, null будут приводить к ререндеру при изменении их значения. Значения типов
array, object, function будут вызывать повторную визуализацию КАЖДЫЙ раз, потому что их равенство объектов всегда будет
возвращать false. Потому что они сравниваются по ссылке.

useMemo может помочь вам оптимизировать функциональные компоненты, не пересчитывая значение переменной при каждом
рендеринге. Он принимает список зависимостей в качестве аргумента, и когда он изменяется, он пересчитывает значение.

Важным инструментом, предотвращающим ненужный повторный рендеринг мемоизированных компонентов, является useCallback.
useCallback концептуально схож с useMemo. Единственное отличие состоит в том, что вместо того, чтобы запоминать
значение, useCallback запоминает функцию.

**Когда и что использовать**

_**memo**_

Что оно делает:

- Обертывает функциональный компонент, перерисовывая компонент только тогда, когда проп или состояние «поверхностно»
  изменились.

Когда его использовать:

- Вы хотите перерендерить компонент только в том случае, если проп изменился (он все равно будет перерисовываться при
  обновлении внутреннего состояния).
- Компонент среднего или большого размера или находится выше в дереве React.
- Компонент часто перерисовывается с заметно низкой производительностью.
- Компонент функциональный (не классовый).

Когда не использовать:

- Чтобы обернуть классовый компоненты (для классовых компонентов используется PureComponent).
- Компонент небольшой или находится ниже в React дереве.
- Компонент не имеет заметно низкой производительности.

_**useMemo**_

Что оно делает:

- Запоминает значение, которое будет пересчитываться только при изменении одной из его зависимостей.

Когда его использовать:

- Вы передаете переменную в мемоизированный компонент, при этом тип переменной не относится к типу boolean, string,
  number, undefined, null. Чаще всего оборачивает массивы и объекты.
- Только внутри функциональных компонентов

Когда не использовать:

- Вы передаете переменную в мемоизированный компонент, который возвращает true со строгим равенством JS (===).
- В классовых компонентах.

_**useCallback**_

Что оно делает:

- Запоминает функцию, которая будет пересчитываться только при изменении одной из ее зависимостей.

Когда его использовать:

- Вы передаете локально объявленную функцию в мемоизированный компонент или другой массив мемоизированных зависимостей.
- Компонент - функциональный

Когда не использовать:

- У вас есть функция, которая не передается в мемоизированный компонент.
- Вы можете легко переместить свою функцию за пределы компонента (очень простые аргументы функции).

https://it-dev-journal.ru/articles/optimizacziya-proizvoditelnosti-react-memo-use-memo-use-callback

https://habr.com/ru/articles/666522/

https://habr.com/ru/companies/oleg-bunin/articles/749294/

https://medium.com/nuances-of-programming/%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3-%D0%B8-%D0%BC%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-react-3328fa87ccb#
</details>

<details><summary><b>Батчинг</b></summary>
Батчингом в React называют процесс группировки нескольких вызовов обновления состояния в один этап ререндера.

До React 18 батчинг также существовал, но автоматически работал только для обработчиков DOM событий.
До асинхронной функции батчинг работал и происходил только один ререндер, а после ререндерилось всё на каждое обновление
состояния.

В React 18 батчинг работает таким образом, что и до и после асихронной функции обновления состояния объединялись (до
асихроннной ф-ии одна группа, после еще одна)

В 17 версии можно было обеъдинить вызовы сетстейтов при помощи unstable_batchedUpdates. В него помещается коллбэк с
сетСтейтами, которые нужно вызвать без лишнего перерендера.

Обычно батчинг безопасен и не вызывает проблем при разработке, но если сразу после обновления состояния нужно прочитать
изменения в DOM, то можно использовать ReactDOM.flushSync() для отмены батчинга. flushSync позволяет вам заставить React
синхронно промывать любые обновления внутри предоставленного обратного вызова. Это гарантирует, что DOM будет обновлен
немедленно.

https://www.youtube.com/watch?v=lj0JjbVJPz0&ab_channel=%D0%90%D0%B9%D0%A2%D0%B8%D0%A1%D0%B8%D0%BD%D1%8F%D0%BA
</details>

---
