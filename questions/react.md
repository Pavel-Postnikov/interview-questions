<h3>
  <img src="../assets/React.png" width="16" height="16" />
  <span>React:</span>
</h3>

---
1. Что такое React?
2. Перечислите особенности React?
3. Что такое Virtual DOM? Как он работает с React?
4. Для чего нужен атрибут `key` при рендере списков?
5. Что такое `PureComponent`?
6. Что такое Компонент высшего порядка (Higher-Order Component/HOC)?
7. Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?
8. Методы жизненного цикла компонента в React?
9. Стадии жизненного цикла компонента в React?
10. Что такое React Reconciliation?
11. Что такое портал (`Portal`)?
12. Что такое контекст (`Context`)?
13. Что такое React хуки (Hooks)?
14. Что Такое `JSX`?
15. Разница между состоянием(`state`) и пропсами(`props`)?
16. Что такое React Fiber?
17. Что такое фрагмент (`Fragment`)? Почему фрагмент лучше, чем `div`?
<details><summary><b>Что такое синтетические события в React?</b></summary>
    
**SyntheticEvent** - это кроссбраузерная обертка для нативных событий браузера. Этот API аналогичен браузерному, включая stopPropagation() и preventDefault(), но работает одинаково во всех браузерах.
</details>
<details><summary><b>Что такое React-ссылка (`ref`)? Как создать ссылку?</b></summary>
Refs предоставляет способ доступа к DOM-узлам или React-элементам, созданным в методе render().

Есть несколько хороших примеров использования ссылок:
- Управление фокусом, выделение текста или воспроизведение медиаресурсами.
- Выполнение анимаций в императивном подходе.
- Интеграция со сторонними библиотеками, взаимодействующие с DOM.

Частой ошибкой разработчиков React является использование useState для каждого изменяемого значения, которое нужно сохранить между процессами рендера. useState — хорошее решение, если выводимый результат зависит от значения, в противном случае лучше применять useRef.

Значение ссылки отличается в зависимости от типа узла:
- Когда атрибут ref используется в HTML-элементе, ref, созданный в конструкторе с помощью React.createRef(), получает базовый элемент DOM в качестве своего свойства current.
- Когда атрибут ref используется на пользовательском классовом компоненте, объектref получает примонтированный экземпляр компонента в качестве своего свойства current.
- Вы не можете использовать атрибут ref в функциональных компонентах, потому что у них не может быть экземпляров.

Создать ссылку можно двумя способами:
- createRef() используется в классовых компонентах и привязываются к элементу с помощью атрибута ref. Получить доступ к значению можно обратившись к атрибуту current. При использовании в функциональных компонентах будет создаваться на каждый рендер, что влияет на оптимизацию приложения.
- Поэтому, в функциональных приложениях лучше пользоваться хуком useRef(), который при каждом повторном рендере сохраняет ссылку на объект ref, созданный при первом монтировании. 

[Ссылки в React] https://habr.com/ru/articles/540442/
</details>

20. Разница между теневым (Shadow) и виртуальным (Virtual) DOM?
21. Назовите преимущества использования React?
<details><summary><b>Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?</b></summary>

Условный рендеринг (conditional rendering) означает отображение элементов в пользовательском интерфейсе только в том случае, если выполняется определенное условие, в противном случае элементы скроются.

Для условного рендеринга (conditional rendering) можно использовать обычные if или тернарные операторы. Кроме того, в JSX можно встраивать любое выражение посредством оборачивания его в фигурные скобки, а также совместно с логическим оператором && (короткие вычисления).

<code>

    <h1>Привет!</h1>
    {
    messages.length > 0 && !isLogin
        ? (<h2>
            У вас {messages.length} непрочитанных сообщений.
        </h2>)
        : (<h2>
            У вас нет непрочитанных сообщений.
        </h2>)
    }
</code>
</details>

23. Что такое компонент-переключатель (Switching Component)?
24. Разница между `React` и `ReactDOM`?
25. Разница между компонентом и контейнером?
<details><summary><b>Как React обрабатывает, или ограничивает использование пропсов определенного типа?</b></summary>

PropTypes - хороший способ перехвата ошибок, связанных с неправильными типами props.

PropTypes позволяет помечать пропы как обязательные или определять их значения по умолчанию.

    import React from 'react'
    import PropTypes from 'prop-types'

    const Person = (props) => (
        <div>
            <h1>{props.firstName} {props.lastName}</h1>
            {props.country ? <p>Страна: {props.country}</p> : null}
        </div>
    )

    Person.propTypes = {
        firstName: PropTypes.string,
        lastName: PropTypes.string,
        country: PropTypes.string
    }

    export default Person

PropTypes определяет тип пропа. Каждый раз, когда через проп передается какое-либо значение, оно проверяется на правильный тип. Если будет обнаружен неправильный тип, в консоль будет выведено сообщение об ошибке.
</details>

27. Что такое строгий режим в React? Его преимущества?
<details><summary><b>Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?</b></summary>

В React пропы передаются в одном направлении, сверху вниз, от родительского компонента к дочернему, и последовательно. При наличии незначительного количества пропов или потомков - это не является проблемой. Однако при росте приложения для того, чтобы передать пропы с верхнего уровня приложения компонентам, находящимся на 3 или 4 уровне вложенности, нам приходится передавать одни и те же пропы на каждом уровне дерева компонентов. Это называется бурением пропов (prop drilling).

Context API

Контекст решает некоторые проблемы, связанные с "бурением". Он позволяет компонентам получать данные на любом уровне без их передачи в виде пропов. Передаваемыми данными может быть что угодно: состояние, функция, объект и т.д. Эти данные доступны любым вложенным компонентам в пределах области видимости контекста.

    import React from "react"
    import ReactDOM from "react-dom"

    // создаем контекст
    const NumberContext = React.createContext() // он возвращает объект с двумя значениями   { Provider, Consumer }

    function App() {
        // используем провайдер для предоставления потомкам доступа к данным
        return (
            <NumberContext.Provider value={10}>
                <div>
                  <Display />
                </div>
            </NumberContext.Provider>
        )
    }

    function Display() {
        // извлекаем значение из контекста
        const value = useContext(NumberContext)

        return <div>Ответ: {value}.</div>
    }
</details>

29. Что такое «опрос» (Polling)? Как его реализовать в React?
<details><summary><b>Разница между элементом и компонентом?</b></summary>
Элемент - это обычный объект, описывающий, что мы хотим увидеть на экране в терминах узлов и других частей DOM. Элементы могут содержать другие элементы в своих свойствах. Создавать элементы в React легко. Однако после создания, элемент не подлежит изменению.

Объектное представление React-элемента выглядит так:
   
    const element = React.createElement(
        'div',
        { id: 'login-btn' },
        'Войти'
    )
Функция React.createElement возвращает такой объект:

    {
        type: 'div',
        props: {
            children: 'Войти',
            id: 'login-btn'
        }
    }
Данный объект рендерится с помощью ReactDOM.render():
    
    <div id='login-btn'>Login</div>

В отличие от элемента, компонент может определяться по-разному. Он может быть классом с методом render (классовый компонент) или простой функцией (функциональный компонент). В любом случае компонент принимает свойства (пропы, props от properties) на вход и возвращает JSX:

    const Button = ({ onLogin }) =>
        <div id={'login-btn'} onClick={onLogin}>Войти</div>
JSX транспилируется (преобразуется) в функцию React.createElement:

    const Button = ({ onLogin }) => React.createElement(
        'div',
        { id: 'login-btn', onClick: onLogin },
        'Войти'
    )
</details>

31. Что такое `ReactDOMServer`?
32. Что такое предохранители (Error Boundaries)?
33. Что такое «ленивая» (Lazy) функция?
34. Разница между рендерингом и монтированием?
35. Что такое `сhildren`?
36. Что такое события указателя (Pointer Events)?
37. Что такое инверсия наследования (Inheritance Inversion)?
38. Как в React реализовать двустороннее связывание данных?
39. Разница между классовым и функциональным компонентами?
40. Разница между `useEffect()` и `componentDidMount()`?
41. Преимущества хуков?
42. Недостатки хуков?
<details><summary><b>Правила (ограничения) использования хуков?</b></summary>
    Хуки имеют ряд ограничений при определении и использовании:

Хуки вызываются только на верхнем уровне (top-level) компонента.
Не вызывайте хуки внутри циклов, условных операторов или вложенных функций. Вместо этого всегда используйте хуки только внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента.

Хуки можно вызывать только из функциональных компонентов React, либо из других хуков. Но их нельзя вызывать из классов-компонентов.
Следуя этому правилу, можно гарантировать, что вся логика состояния компонента чётко видна из исходного кода.
</details>

44. Что такое поднятие состояния вверх (Lifting State Up)?
45. Что делает метод `shouldComponentUpdate`?
<details><summary><b>Разница между `createElement()` и `cloneElement()`?</b></summary>

**React.createElement()** используется для создания элементов. Всякий раз, когда мы пишем код в JSX, JSX преобразует его в React.createElement(). Метод createElement использовать не рекомендуется, поскольку его очень сложно поддерживать и отлаживать. Нам приходится вызывать метод React.createElement() каждый раз для создания элемента React, даже если это просто тег span без атрибутов.


**React.cloneElement()** используется, когда родительский компонент хочет добавить или изменить props своих дочерних элементов. Функция React.cloneElement() создает клон данного элемента, и мы также можем передавать в функцию реквизиты и дочерние элементы.
</details>

<details><summary><b>Что такое `useReducer()`?</b></summary>

useReducer - это хук, принимающий функцию-редуктор и начальное состояние приложения в качестве параметров и возвращающий текущее состояние и диспетчер (dispatcher) для отправки (dispatch) операций для обновления состояния.

Несмотря на то, что useState - это базовый хук, а useReducer - продвинутый, на самом деле useState() реализован с помощью useReducer(). Это означает, что useReducer() - это примитив, который может использоваться во всех случаях использования useState(). Редуктор - мощный инструмент, который может использоваться в самых разных сценариях.

    import React, { useReducer } from 'react'

    const initialState = 0

    const reducer = (state, action) => {
        switch (action) {
            case 'increment': return state + 1
            case 'decrement': return state - 1
            case 'reset': return 0
            default: return state
        }
    }

    const ReducerExample = () => {
        const [count, dispatch] = useReducer(reducer, initialState)

        return (
            <div>
                {count}
                <button onClick={() => dispatch('increment')}>+</button>
                <button onClick={() => dispatch('decrement')}>-</button>
                <button onClick={() => dispatch('reset')}>0</button>
            </div>
        )
    }

    export default ReducerExample
Сначала мы определяем начальное состояние и редуктор. Затем передаем их в useReducer(). Хук возвращает текущее значение состояния и диспетчер, который используется для обновления состояния. Когда пользователь нажимает на кнопку, происходит отправка определенной операции в редуктор, который обновляет счетчик на основе операции. Мы может определять столько операций, сколько требуется нашему приложению.
</details>
<details><summary><b>Как реализовать однократное выполнение операции при начальном рендеринге?</b></summary>

Для этого можно использовать метод жизненного цикла componentDidMount в классовом компоненте:
    
    class Homepage extends React.Component {
        componentDidMount() {
            trackPageView('Homepage')
        }

        render() {
            return <div>Домашняя страница</div>
        }
    }

Любые операции, определенные в componentDidMount(), будут выполнены только один раз при монтировании компонента.

Аналогичный функционал можно реализовать с помощью хука useEffect с пустым массивом зависимостей:

    const Homepage = () => {
        useEffect(() => {
            trackPageView('Homepage')
        }, [])

        return <div>Домашняя страница</div>
    }

Второй параметр контролирует запуск эффекта:

- Если второй параметр отсутствует, эффект выполняется при каждом рендеринге.
- Если массив содержит переменные, то эффект запускается при монтировании компонента, а также при каждом изменении любой переменной.
- Если массив является пустым, то эффект будет запущен только один раз при монтировании компонента. В этом случае функционал будет аналогичен вызову componentDidMount() в классовом компоненте.
</details>

49. Что такое распределенный компонент?
50. Расскажите о хуках `useCallback()`, `useMemo()`, `useImperativeHandle()`, `useLayoutEffect()`?
51. Как отрендерить HTML код в React-компоненте?
52. Зачем в `setState()` нужно передавать функцию?
53. Для чего предназначен метод `registerServiceWorker()` в React?
54. Чем React Router отличается от обычной маршрутизации?
55. Какие хуки были добавлены в React Router версии 5?
56. Как передавать пропсы в React Router?
57. Что такое Reselect и как он работает?
58. Назовите основную цель React Fiber?
59. Какие типы данных может возвращать `render`?
60. Разница между `memo` и `useMemo`?
61. Что такое синтетические события (SyntheticEvent) в React?
62. Является ли React реактивным?
63. Техники оптимизации перфоманса React?
64. Лучшие практики безопасности в React?
<details><summary><b>Мемоизация в React</b></summary>
Одной из наиболее важных концепций, которую необходимо понять для оптимизации React, является мемоизация. Мемоизация — это процесс кэширования результатов работы функции и возврата кэша при последующих запросах.

memo по умолчанию предотвратит повторный рендеринг компонента. Он будет перерисовывать компонент только в том случае, если внутреннее состояние или проп изменяются. Сравнение происходит поверхностно. Рассмотрим такой пример.

При сравнении пропсов, чтобы определить, должен ли компонент обновляться, memo поверхностно сравнивает пропсы. Можно представить поверхностное сравнение, как строгое сравнении JS (===) для каждого prevProp и каждого newProp. Если все возвращают true, повторный рендеринг не запускается, если все возвращают false, то рендеринг запускается. Т.е. значения типов boolean, string, number, undefined, null будут приводить к ререндеру при изменении их значения. Значения типов array, object, function будут вызывать повторную визуализацию КАЖДЫЙ раз, потому что их равенство объектов всегда будет возвращать false. Потому что они сравниваются по ссылке.

useMemo может помочь вам оптимизировать функциональные компоненты, не пересчитывая значение переменной при каждом рендеринге. Он принимает список зависимостей в качестве аргумента, и когда он изменяется, он пересчитывает значение.

Важным инструментом, предотвращающим ненужный повторный рендеринг мемоизированных компонентов, является useCallback. useCallback концептуально схож с useMemo. Единственное отличие состоит в том, что вместо того, чтобы запоминать значение, useCallback запоминает функцию.

**Когда и что использовать**

_**memo**_

Что оно делает:
- Обертывает функциональный компонент, перерисовывая компонент только тогда, когда проп или состояние «поверхностно» изменились.

Когда его использовать:
- Вы хотите перерендерить компонент только в том случае, если проп изменился (он все равно будет перерисовываться при обновлении внутреннего состояния).
- Компонент среднего или большого размера или находится выше в дереве React.
- Компонент часто перерисовывается с заметно низкой производительностью.
- Компонент функциональный (не классовый).

Когда не использовать:
- Чтобы обернуть классовый компоненты (для классовых компонентов используется PureComponent).
- Компонент небольшой или находится ниже в React дереве.
- Компонент не имеет заметно низкой производительности.

_**useMemo**_

Что оно делает:
- Запоминает значение, которое будет пересчитываться только при изменении одной из его зависимостей.

Когда его использовать:
- Вы передаете переменную в мемоизированный компонент, при этом тип переменной не относится к типу boolean, string, number, undefined, null. Чаще всего оборачивает массивы и объекты.
- Только внутри функциональных компонентов 

Когда не использовать:
- Вы передаете переменную в мемоизированный компонент, который возвращает true со строгим равенством JS (===).
- В классовых компонентах.

_**useCallback**_

Что оно делает:
- Запоминает функцию, которая будет пересчитываться только при изменении одной из ее зависимостей.

Когда его использовать:
- Вы передаете локально объявленную функцию в мемоизированный компонент или другой массив мемоизированных зависимостей.
- Компонент - функциональный

Когда не использовать:
- У вас есть функция, которая не передается в мемоизированный компонент.
- Вы можете легко переместить свою функцию за пределы компонента (очень простые аргументы функции).

https://it-dev-journal.ru/articles/optimizacziya-proizvoditelnosti-react-memo-use-memo-use-callback

https://habr.com/ru/articles/666522/

https://habr.com/ru/companies/oleg-bunin/articles/749294/

https://medium.com/nuances-of-programming/%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3-%D0%B8-%D0%BC%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-react-3328fa87ccb#
</details>

---
