<h3>
  <img src="../assets/JavaScript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3>


---
<details><summary><b>Типы данных в JavaScript?</b></summary>
В js есть 8 основных типов данных:
string, number, boolean, bigInt (int значения, которые слишком велики для number), object, null, undefined, symbol

Примитивные типы данных:
string, boolean, number, undefined

Сложные типы данных:
function, object

Объектный типы данных:
object, array, date
</details>
<details><summary><b>Разница между `==` и `===` (нестрогое/строгое равенство)?</b></summary>
Оператор <b>нестрогого равенства (==)</b> перед сравнением оператор равенства приводит обе величины к общему типу.
Это означает, что если типы данных сравниваемых операндов различны, то JavaScript автоматически преобразует один из операндов в тот же тип, что и другой, чтобы их можно было сравнить.

Правила для приведения типов в JavaScript:
- Если один из операндов является строкой, то второй операнд будет преобразован в строку.
- Если один из операндов является числом, другой операнд будет преобразован в число.
- Если один из операндов является булевым значением, он будет преобразован в число (true станет 1, а false — 0).
- Если один из операндов является объектом, а другой — примитивным значением, то перед сравнением объект будет преобразован в примитивное значение.
- Если один из операндов равен null или undefined, то, чтобы при сравнении вернулось true, второй тоже должен быть null или undefined. В противном случае возвращается false.

Оператор <b>строгого равенства (===)</b> проверяет равенство без приведения типов.
При сравнении переменных сначала проверяется, отличаются ли их типы. Если да, то возвращается false. Если типы совпадают, то проверяется значение. Если значения одинаковы и не являются числами, возвращается true.
Наконец, если оба операнда — числа и не NaN, и у них одинаковое значение, то возвращается true. В противном случае — false.

[Операторы сравнения] https://developer.mozilla.org/ru/docs/Web/JavaScript/Equality_comparisons_and_sameness
</details>
<details><summary><b>Что такое Strict mode в JavaScript?</b></summary>
Строгий режим или Strict — это функция, представленная в ECMAScript 5 (ES5), которая позволяет разработчикам использовать более строгий и безопасный вариант JavaScript.

При активации он применяет строгие правила и ограничения, помогая выявлять распространенные ошибки и повышать качество кода. Строгий режим можно включить для каждого файла или функции, что позволяет разработчикам выбирать, где применять его ограничения.

<b>Ограничения strict-режима</b>
- Объявление переменной. В строгом режиме вы должны объявить переменные с помощью ключевых слов var, let или const перед их использованием. В противном случае возникнет ошибка.
- Повторяющиеся имена параметров. Строгий режим запрещает функции с повторяющимися именами параметров. При попытке использовать их возникнет синтаксическая ошибка.
- Восьмеричные литералы (например, 0123) не допускаются в строгом режиме, и попытка их использования приведет к синтаксической ошибке. Вместо этого используйте префикс 0o для восьмеричных чисел.
- В строгом режиме попытка присвоить значение свойству, доступному только для чтения (например, глобальной переменной, такой как undefined, или свойству только для чтения встроенного объекта) приведет к ошибке TypeError.
- Оператор with запрещен в строгом режиме, так как он может привести к неоднозначному и трудно отлаживаемому коду.
- В строгом режиме eval имеет собственную область видимости, и переменные, объявленные внутри вызова eval, не попадают в окружающую область.
-В нестрогом режиме значение this внутри функции, вызываемой без явного получателя (например, в качестве отдельной функции, а не метода), по умолчанию равно глобальному объекту. В строгом режиме this является undefined, что помогает предотвратить случайные изменения глобального объекта.

[Strict режим] https://tproger.ru/articles/ponimanie-strogogo-rezhima-javascript
</details>
<details><summary><b>Разница между function declaration и function expression?</b></summary>
1. this <br/>
1.1 <b><i>Обыкновенные функции</i></b> - значение this динамическое, зависит от того, как была вызвана функция:<br/>
        а) во время обычного выполнения this = глобальному объекту;<br/>
        б) во время выполнения ф-ии объекта значение = объекту, у которого был вызван метод;<br/>
        в) с помощью call, apply или bind this = 1му аргументу;<br/>
        г) с помощью конструктора используя ключевое слово new, значение this = новосозданной сущности  <br/>
    1.2 В <b><i>стрелочной ф-ии</i></b> значение this = this внешней ф-ии. Ф-ия не создает собственный контекст, а использует внешний.<br/>
<br/>
2. Конструкторы <br/>
2.1 <b><i>Обычная ф-ия</i></b> может легко создать объекты <br/>
2.2 <b><i>Стрелочная ф-ия</i></b> не имеет this и не может создавать объекты <br/>
<br/>
3. Объект arguments <br/>
3.1 Внутри тела <b><i>обычной ф-ии</i></b> существует специальный массив arguments, содержащий список аргументов, с которым ф-ия была вызвана. <br/>
3.2 В <b><i>стрелочной ф-ии</i></b> отсутствует arguments,  их значение будет браться из внешней ф-ии, но можно использовать деструктуризацию (...args).<br/>
<br/>
4. Неявный return <br/>
4.1 Только использование return вернет результат в <b><i>обычной ф-ии</i></b>.<br/>
4.2 Если <b><i>стрелочная ф-ия</i></b> содержит одну инструкцию и опущены фигурные скобки, то выражение вернется автоматически<br/>
<br/>
5. Методы <br/>
5.1 Нужно руками привязывать this к <b><i>обычной ф-ии</i></b>.<br/>
5.2 Метод с использованием <b><i>стрелочной ф-ии</i></b> привязывает this объекту класса.<br/>
<br/>
</details>
<details><summary><b>Разница между `null` и `undefined`?</b></summary>
<b><i>null</i></b> – явно присвоенное значение отсутствия, обозначает понятия «отсутствует», «ничего», «пусто» или «значение неизвестно».
В JavaScript null используется только для обозначения конца цепочки прототипов, чтобы показать, что следующий прототип отсутствует.

<b><i>undefined</i></b> – неявное отсутствие, переменную объявили, но не инициализировали.

<b><i>0</i></b> – самая "жирная" пустота, полноценное значение численной переменной.
</details>
<details><summary><b>Типы таймеров в JavaScript?</b></summary>
Функции-таймеры реализуются на уровне браузера, поэтому в разных браузерах их реализации отличаются.
<br/>В браузерах основные функции-таймеры относятся к интерфейсу Window, также связанному с некоторыми другими функциями и объектами. Этот интерфейс предоставляет ко всем своим элементам глобальный доступ в главной области видимости JavaScript. Вот почему функцию setTimeout можно выполнять непосредственно в консоли браузера.
<br/><br/>Для одноразового выполнения действий через промежуток времени предназначена функция <b><i>setTimeout()</i></b>. Она может принимать два параметра:

<code>var timerId = setTimeout(someFunction, period)</code>
<br/><br/>Если функция, для задержки которой используется setTimeout, принимает какие-либо аргументы, то можно использовать оставшиеся аргументы самой функции setTimeout для переброски значений аргументов к отложенной функции.

<code>// Для: func(arg1, arg2, arg3, ...)<br/>
// Можно использовать: setTimeout(func, delay, arg1, arg2, arg3, ...)
</code>

Для остановки таймера применяется функция <b><i>clearTimeout()</i></b>.

Функции <b><i>setInterval()</i></b> и <b><i>clearInterval()</i></b> работают аналогично функциям setTimeout() и clearTimeout() с той лишь разницей, что setInterval() постоянно выполняет определенную функцию через промежуток времени.

Метод <b><i>requestAnimationFrame()</i></b> действует аналогично setInterval() за тем исключением, что он больше заточен под анимации, работу с графикой и имеет ряд оптимизаций, которые улучшают его производительность.

<code>function rotate() {
angle = (angle + 2)%360;
square.style.transform = "rotate(" + angle + "deg)";
window.requestAnimationFrame(rotate);
}</code>

В метод window.requestAnimationFrame() передается функция, которая будет вызываться определенное количество раз (обычно 60) в секунду. В данном случае в этот метод передается функция rotate, которая изменяет угол поворота блока на странице и затем обращается опять же к методу window.requestAnimationFrame(rotate).

[Статья 1] https://habr.com/ru/companies/piter/articles/426709/
[Статья 2] https://metanit.com/web/javascript/7.6.php
</details>
<details><summary><b>Что такое поднятие (Hoisting)?</b></summary>
<b>Поднятие</b> – механизм JS, в котором переменные и ф-ии передвигаются вверх своей области видимости перед тем, как код будет выполнен.

<b><i>var</i></b> – поднимает объявление и присваивает undefined;<br/>
<b><i>let</i></b> – при использовании до объявления выдаст ReferenceError, при использованиидо инициализации – undefined;<br/>
<b><i>const</i></b> – до объявления и инициализации выдаст ReferenceError.<br/>

<i>Поднятие функций:</i> 
- объявленные ф-ии <u>полностью</u> поднимаются вверх кода;
- функциональные выражения <u>не поднимаются</u>.

<i>Приоритет:</i>
- инициализация переменных имеет приоритет над объявлением ф-ий;
- объявление ф-ий имеет приоритет перед объявлением (<u>без инициализации!</u>) переменных.

<i>Поднятия классов:</i>
- объявления классов поднимаются как и ф-ии, но остаются неинициализированными до их объявления (ReferenceError);
- классовые выражения не поднимаются.
</details>
<details><summary><b>Что такое область видимости (Scope)?</b></summary>
<i>Область видимости</i> — это зона доступности переменных.
<b><i>Глобальная область видимости</i></b> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости.
JS в браузерах так устроен, что глобальные переменные попадают в объект window.

Если вы присваиваете значение переменной, которая ранее не была декларирована, то эта переменная автоматически становится глобальной.

<b><i>Блочная область видимости</i></b> (let, const) ограничена программным блоком, обозначенным при помощи { и }. Простейший пример такой области — это выражение внутри скобок:

<b><i>Функциональная область видимости</i></b> (var) — это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции.

[Область видимости] https://doka.guide/js/closures/
</details>
<details><summary><b>Разница между `var`, `let` и `const`?</b></summary>
<b><i>var</i></b> – функциональная область видимости, значение может быть переопределено и переобъявлено, объявленные значения поднимаются наверх;

<b><i>let</i></b> – блочная область видимости, не могут быть переобъявлены, но могут быть переопределены, поднимается только объявление, но не значение (на верху undefined);

<b><i>const</i></b> – блочная область видимости, не могут быть переобъявлены и переопределены, поднимается наверх, не не инициализируется, нужно инициализировать во время объявления.
Const не значит константное значение. Это значит константную ссылку на значение, а именно:

<u>НЕЛЬЗЯ:</u>
- переназначить постоянное значение;
- переназначить константный массив;
- переназначить константный объект.

<u>МОЖНО:</u>
- изменить элементы константного массива;
- изменить свойства константного объекта.
</details>

<details><summary><b>Что такое замыкание (Closure)?</b></summary>
<b><i>Замыкание</i></b> – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

Когда запускается функция, в начале ее вызова автоматически создается новое лексическое окружение для хранения локальных переменных и параметров вызова.

В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):Внутреннее лексическое окружение соответствует текущему выполнению. Внешнее лексическое окружение – это глобальное лексическое окружение. У внутреннего лексического окружения есть ссылка на внешнее outer.

<b>Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.</b>

<code>

    const add = (function() {
        let counter = 0;
        return function() { 
            counter+=1;
            return counter;
        }
    })();
    add(); //counter = 1
    add(); //counter = 2
    add(); //counter = 3
</code>

<b>Замыкания и циклы</b>

<u>Для цикла у каждой итерации своё отдельное лексическое окружение</u>

<i>Работа цикла с лексическим окружением <u>без</u> вложенных функций</i>

На первой итерации для внутреннего содержимого (ограниченного фигурными скобками {}) цикла создается объект-лексическое окружение с хранилищем локальных для цикла переменных и ссылкой на внешнее лексическое окружение. На следующей итерации локальные переменные из лексического окружения предыдущей итерации копируются в хранилище нового лексического окружения, созданного для текущей итерации цикла. И так далее.

Как только цикл перешел на очередную итерацию, в программе не остается ссылок на лексическое окружение прошлой итерации, то есть становится недостижимым и поэтому автоматически уничтожается сборщиком мусора.

Таким образом, в памяти большую часть времени присутствует для цикла лишь одно лексическое окружение, относящееся к текущей итерации цикла. После окончания работы цикла все объекты-лексические окружения, которые были созданы для итераций цикла, оказываются уничтоженными сборщиком мусора.

<i>Работа цикла с <u>с</u> содержимым вложенной функций</i>

Для каждой итерации создается новое лексическое окружение. Однако, из-за того, что ссылка на лексическое окружение каждой итерации записывается в скрытое свойство Environment вложенной в цикл функции, после окончания каждой итерации ее лексическое окружение остается достижимым из программы и поэтому не унитожается сборщиком мусора.

<code>

    var result = [];
    for (var i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //5, ожидалось 0
    result[1](); //5, ожидалось 1
    result[2](); //5, ожидалось 2
</code>

Окружение при выходе из цикла:

<code>
    
    environment: {
        Environment: {
            result: [...],
            i: 5
        },
        outer: null
    }
</code>

Каждый раз, когда i увеличивается, обновляется область видимости, а она является общей для всех функций. 
Из-за этого любая из 5 функций, пытающихся получить доступ к i, возвращает 5, i === 5, когда цикл завершается.

Исправить можно использованием let вместо var, тк let находится в операторе блока и поэтому новая привязка идентификатора замыкания создается для каждой итерации в цикле for.

<code>

    var result = [];
    for (let i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //0
    result[1](); //1
    result[2](); //2
</code>

[Замыкания] https://learn.javascript.ru/closure <br/>
[Замыкания и циклы] https://ilyachalov.livejournal.com/163300.html
</details>

11. Что обозначает `this` в JavaScript?
12. Что такое функции высшего порядка (Higher Order Functions)?
13. Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?
14. Методы строк в JavaScript?
15. Методы массивов в JavaScript?
16. Что такое чистая функция?
17. Разница между `.forEach()` и `.map()`?
18. Разница между `.call()`, `.apply()` и `bind()`?
19. Почему в JS функции называют объектами первого класса?
20. Как определить наличие свойства в объекте?
21. Что такое IIFE?
22. Что такое псевдомассив `arguments`?
23. Разница между host-объектами и нативными объектами?
24. Почему результат сравнения 2х объектов это `false`?
25. Что такое прототипное наследование? Как создать объект без прототипа?
26. Почему расширение нативных JavaScript-объектов это плохая практика?
27. Что такое `NaN`? Как определить, что значение равно `NaN`?
28. Что такое объектная обертка (Wrapper Objects)?
29. Как в JavaScript создать объект?
30. Для чего используется ключевое слово `new`?
31. Операторы «И» и «ИЛИ» (`&&` и `||`)?
32. Для чего используется оператор двойного отрицания (`!!`)?
33. Для чего используется оператор остатка (`%`)?
34. Как проверить, является ли значение массивом?
35. Как работает boxing/unboxing в JavaScript?
36. Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?
37. Разница между оператором `in` и методом `.hasOwnProperty()`?
38. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?
39. Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?
40. Что такое необъявленная переменная?
41. Как передаются параметры в функцию: по ссылке или по значению?
42. Что такое прототип объекта в JavaScript?
43. Как работает метод `Object.create()`?
44. Разниц между `Object.freeze()` и `Object.seal()`?
45. Разница между методами `.slice()` и `.splice()`?
46. Как работают методы `.find()`, `.findIndex()` и `.indexOf()`?
47. Плюсы и минусы использования `use strict`?
48. Разница между методами `.push()`, `.pop()`, `.shift()` и `.unshift()`?
49. Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?
50. Типы всплывающих окон в JavaScript?
51. Типы объектов JavaScript?
52. Парадигмы программирования в JavaScript?
53. Типы ошибок в JavaScript?
54. Разница между `typeof` и `instanceof`?
55. JavaScript статически, или динамически типизированный язык?
56. Что такое регулярное выражение (Regular Expression)?
57. Что такое рекурсия?
58. Что такое прототип (Prototype) объекта?
59. Какие методы используются в регулярных выражениях?
60. Что такое полифил (polyfill)?
61. Что такое `switch/case`? Правила использования `switch/case`?
62. Типы функций по способности принимать другие функции?
63. Что такое выражения (expression) и инструкции (statement) в JavaScript?
64. Разница между `.some()` и `.every()`?
65. Как сгенерировать случайное число в JavaScript?
66. Типы операторов в JavaScript?
67. Разница между параметром и аргументом функции?
68. Правила задания имён для переменных и функций в JavaScript?
69. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?
70. Для чего применяется метод `Array.from()`?
71. Назовите способы преобразования массива в объект?
72. Разница между `Object` и `Map`?
73. Что такое каррирование?
74. Для чего используются метод `Object.seal()`?
75. Для чего используется свойство `.dataset`?
76. Каким образом можно обмениваться кодом между файлами?
77. Как работает «сборщик мусора» в JavaScript?
78. Что такое утечки памяти?
79. Назовите основные типы утечек памяти в JavaScript?
80. Как работает контекст выполнения (execution context) в JavaScript?
81. Разница между примитивом и объектом?
---
