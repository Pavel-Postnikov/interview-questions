<h3>
  <img src="../assets/JavaScript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3>


---
<details><summary><b>Типы данных в JavaScript?</b></summary>
В js есть 8 основных типов данных:
string, number, boolean, bigInt (int значения, которые слишком велики для number), object, null, undefined, symbol

Примитивные типы данных:
string, boolean, number, undefined

Сложные типы данных:
function, object

Объектный типы данных:
object, array, date
</details>
<details><summary><b>Разница между `==` и `===` (нестрогое/строгое равенство)?</b></summary>
Оператор <b>нестрогого равенства (==)</b> перед сравнением оператор равенства приводит обе величины к общему типу.
Это означает, что если типы данных сравниваемых операндов различны, то JavaScript автоматически преобразует один из операндов в тот же тип, что и другой, чтобы их можно было сравнить.

Правила для приведения типов в JavaScript:
- Если один из операндов является строкой, то второй операнд будет преобразован в строку.
- Если один из операндов является числом, другой операнд будет преобразован в число.
- Если один из операндов является булевым значением, он будет преобразован в число (true станет 1, а false — 0).
- Если один из операндов является объектом, а другой — примитивным значением, то перед сравнением объект будет преобразован в примитивное значение.
- Если один из операндов равен null или undefined, то, чтобы при сравнении вернулось true, второй тоже должен быть null или undefined. В противном случае возвращается false.

Оператор <b>строгого равенства (===)</b> проверяет равенство без приведения типов.
При сравнении переменных сначала проверяется, отличаются ли их типы. Если да, то возвращается false. Если типы совпадают, то проверяется значение. Если значения одинаковы и не являются числами, возвращается true.
Наконец, если оба операнда — числа и не NaN, и у них одинаковое значение, то возвращается true. В противном случае — false.

[Операторы сравнения] https://developer.mozilla.org/ru/docs/Web/JavaScript/Equality_comparisons_and_sameness
</details>
<details><summary><b>Что такое Strict mode в JavaScript?</b></summary>
Строгий режим или Strict — это функция, представленная в ECMAScript 5 (ES5), которая позволяет разработчикам использовать более строгий и безопасный вариант JavaScript.

При активации он применяет строгие правила и ограничения, помогая выявлять распространенные ошибки и повышать качество кода. Строгий режим можно включить для каждого файла или функции, что позволяет разработчикам выбирать, где применять его ограничения.

<b>Ограничения strict-режима</b>
- Объявление переменной. В строгом режиме вы должны объявить переменные с помощью ключевых слов var, let или const перед их использованием. В противном случае возникнет ошибка.
- Повторяющиеся имена параметров. Строгий режим запрещает функции с повторяющимися именами параметров. При попытке использовать их возникнет синтаксическая ошибка.
- Восьмеричные литералы (например, 0123) не допускаются в строгом режиме, и попытка их использования приведет к синтаксической ошибке. Вместо этого используйте префикс 0o для восьмеричных чисел.
- В строгом режиме попытка присвоить значение свойству, доступному только для чтения (например, глобальной переменной, такой как undefined, или свойству только для чтения встроенного объекта) приведет к ошибке TypeError.
- Оператор with запрещен в строгом режиме, так как он может привести к неоднозначному и трудно отлаживаемому коду.
- В строгом режиме eval имеет собственную область видимости, и переменные, объявленные внутри вызова eval, не попадают в окружающую область.
-В нестрогом режиме значение this внутри функции, вызываемой без явного получателя (например, в качестве отдельной функции, а не метода), по умолчанию равно глобальному объекту. В строгом режиме this является undefined, что помогает предотвратить случайные изменения глобального объекта.

[Strict режим] https://tproger.ru/articles/ponimanie-strogogo-rezhima-javascript
</details>
<details><summary><b>Разница между function declaration и function expression?</b></summary>
1. this <br/>
1.1 <b><i>Обыкновенные функции</i></b> - значение this динамическое, зависит от того, как была вызвана функция:<br/>
        а) во время обычного выполнения this = глобальному объекту;<br/>
        б) во время выполнения ф-ии объекта значение = объекту, у которого был вызван метод;<br/>
        в) с помощью call, apply или bind this = 1му аргументу;<br/>
        г) с помощью конструктора используя ключевое слово new, значение this = новосозданной сущности  <br/>
    1.2 В <b><i>стрелочной ф-ии</i></b> значение this = this внешней ф-ии. Ф-ия не создает собственный контекст, а использует внешний.<br/>
<br/>
2. Конструкторы <br/>
2.1 <b><i>Обычная ф-ия</i></b> может легко создать объекты <br/>
2.2 <b><i>Стрелочная ф-ия</i></b> не имеет this и не может создавать объекты <br/>
<br/>
3. Объект arguments <br/>
3.1 Внутри тела <b><i>обычной ф-ии</i></b> существует специальный массив arguments, содержащий список аргументов, с которым ф-ия была вызвана. <br/>
3.2 В <b><i>стрелочной ф-ии</i></b> отсутствует arguments,  их значение будет браться из внешней ф-ии, но можно использовать деструктуризацию (...args).<br/>
<br/>
4. Неявный return <br/>
4.1 Только использование return вернет результат в <b><i>обычной ф-ии</i></b>.<br/>
4.2 Если <b><i>стрелочная ф-ия</i></b> содержит одну инструкцию и опущены фигурные скобки, то выражение вернется автоматически<br/>
<br/>
5. Методы <br/>
5.1 Нужно руками привязывать this к <b><i>обычной ф-ии</i></b>.<br/>
5.2 Метод с использованием <b><i>стрелочной ф-ии</i></b> привязывает this объекту класса.<br/>
<br/>
</details>
<details><summary><b>Разница между `null` и `undefined`?</b></summary>
<b><i>null</i></b> – явно присвоенное значение отсутствия, обозначает понятия «отсутствует», «ничего», «пусто» или «значение неизвестно».
В JavaScript null используется только для обозначения конца цепочки прототипов, чтобы показать, что следующий прототип отсутствует.

<b><i>undefined</i></b> – неявное отсутствие, переменную объявили, но не инициализировали.

<b><i>0</i></b> – самая "жирная" пустота, полноценное значение численной переменной.
</details>
<details><summary><b>Типы таймеров в JavaScript?</b></summary>
Функции-таймеры реализуются на уровне браузера, поэтому в разных браузерах их реализации отличаются.
<br/>В браузерах основные функции-таймеры относятся к интерфейсу Window, также связанному с некоторыми другими функциями и объектами. Этот интерфейс предоставляет ко всем своим элементам глобальный доступ в главной области видимости JavaScript. Вот почему функцию setTimeout можно выполнять непосредственно в консоли браузера.
<br/><br/>Для одноразового выполнения действий через промежуток времени предназначена функция <b><i>setTimeout()</i></b>. Она может принимать два параметра:

<code>var timerId = setTimeout(someFunction, period)</code>
<br/><br/>Если функция, для задержки которой используется setTimeout, принимает какие-либо аргументы, то можно использовать оставшиеся аргументы самой функции setTimeout для переброски значений аргументов к отложенной функции.

<code>// Для: func(arg1, arg2, arg3, ...)<br/>
// Можно использовать: setTimeout(func, delay, arg1, arg2, arg3, ...)
</code>

Для остановки таймера применяется функция <b><i>clearTimeout()</i></b>.

Функции <b><i>setInterval()</i></b> и <b><i>clearInterval()</i></b> работают аналогично функциям setTimeout() и clearTimeout() с той лишь разницей, что setInterval() постоянно выполняет определенную функцию через промежуток времени.

Метод <b><i>requestAnimationFrame()</i></b> действует аналогично setInterval() за тем исключением, что он больше заточен под анимации, работу с графикой и имеет ряд оптимизаций, которые улучшают его производительность.

<code>function rotate() {
angle = (angle + 2)%360;
square.style.transform = "rotate(" + angle + "deg)";
window.requestAnimationFrame(rotate);
}</code>

В метод window.requestAnimationFrame() передается функция, которая будет вызываться определенное количество раз (обычно 60) в секунду. В данном случае в этот метод передается функция rotate, которая изменяет угол поворота блока на странице и затем обращается опять же к методу window.requestAnimationFrame(rotate).

[Статья 1] https://habr.com/ru/companies/piter/articles/426709/
[Статья 2] https://metanit.com/web/javascript/7.6.php
</details>
<details><summary><b>Что такое поднятие (Hoisting)?</b></summary>
<b>Поднятие</b> – механизм JS, в котором переменные и ф-ии передвигаются вверх своей области видимости перед тем, как код будет выполнен.

<b><i>var</i></b> – поднимает объявление и присваивает undefined;<br/>
<b><i>let</i></b> – при использовании до объявления выдаст ReferenceError, при использованиидо инициализации – undefined;<br/>
<b><i>const</i></b> – до объявления и инициализации выдаст ReferenceError.<br/>

<i>Поднятие функций:</i> 
- объявленные ф-ии <u>полностью</u> поднимаются вверх кода;
- функциональные выражения <u>не поднимаются</u>.

<i>Приоритет:</i>
- инициализация переменных имеет приоритет над объявлением ф-ий;
- объявление ф-ий имеет приоритет перед объявлением (<u>без инициализации!</u>) переменных.

<i>Поднятия классов:</i>
- объявления классов поднимаются как и ф-ии, но остаются неинициализированными до их объявления (ReferenceError);
- классовые выражения не поднимаются.
</details>
<details><summary><b>Что такое область видимости (Scope)?</b></summary>
<i>Область видимости</i> — это зона доступности переменных.
<b><i>Глобальная область видимости</i></b> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости.
JS в браузерах так устроен, что глобальные переменные попадают в объект window.

Если вы присваиваете значение переменной, которая ранее не была декларирована, то эта переменная автоматически становится глобальной.

<b><i>Блочная область видимости</i></b> (let, const) ограничена программным блоком, обозначенным при помощи { и }. Простейший пример такой области — это выражение внутри скобок:

<b><i>Функциональная область видимости</i></b> (var) — это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции.

[Область видимости] https://doka.guide/js/closures/
</details>
<details><summary><b>Разница между `var`, `let` и `const`?</b></summary>
<b><i>var</i></b> – функциональная область видимости, значение может быть переопределено и переобъявлено, объявленные значения поднимаются наверх;

<b><i>let</i></b> – блочная область видимости, не могут быть переобъявлены, но могут быть переопределены, поднимается только объявление, но не значение (на верху undefined);

<b><i>const</i></b> – блочная область видимости, не могут быть переобъявлены и переопределены, поднимается наверх, не не инициализируется, нужно инициализировать во время объявления.
Const не значит константное значение. Это значит константную ссылку на значение, а именно:

<u>НЕЛЬЗЯ:</u>
- переназначить постоянное значение;
- переназначить константный массив;
- переназначить константный объект.

<u>МОЖНО:</u>
- изменить элементы константного массива;
- изменить свойства константного объекта.
</details>

<details><summary><b>Что такое замыкание (Closure)?</b></summary>
<b><i>Замыкание</i></b> – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

Когда запускается функция, в начале ее вызова автоматически создается новое лексическое окружение для хранения локальных переменных и параметров вызова.

В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):Внутреннее лексическое окружение соответствует текущему выполнению. Внешнее лексическое окружение – это глобальное лексическое окружение. У внутреннего лексического окружения есть ссылка на внешнее outer.

<b>Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.</b>

<code>

    const add = (function() {
        let counter = 0;
        return function() { 
            counter+=1;
            return counter;
        }
    })();
    add(); //counter = 1
    add(); //counter = 2
    add(); //counter = 3
</code>

<b>Замыкания и циклы</b>

<u>Для цикла у каждой итерации своё отдельное лексическое окружение</u>

<i>Работа цикла с лексическим окружением <u>без</u> вложенных функций</i>

На первой итерации для внутреннего содержимого (ограниченного фигурными скобками {}) цикла создается объект-лексическое окружение с хранилищем локальных для цикла переменных и ссылкой на внешнее лексическое окружение. На следующей итерации локальные переменные из лексического окружения предыдущей итерации копируются в хранилище нового лексического окружения, созданного для текущей итерации цикла. И так далее.

Как только цикл перешел на очередную итерацию, в программе не остается ссылок на лексическое окружение прошлой итерации, то есть становится недостижимым и поэтому автоматически уничтожается сборщиком мусора.

Таким образом, в памяти большую часть времени присутствует для цикла лишь одно лексическое окружение, относящееся к текущей итерации цикла. После окончания работы цикла все объекты-лексические окружения, которые были созданы для итераций цикла, оказываются уничтоженными сборщиком мусора.

<i>Работа цикла с <u>с</u> содержимым вложенной функций</i>

Для каждой итерации создается новое лексическое окружение. Однако, из-за того, что ссылка на лексическое окружение каждой итерации записывается в скрытое свойство Environment вложенной в цикл функции, после окончания каждой итерации ее лексическое окружение остается достижимым из программы и поэтому не унитожается сборщиком мусора.

<code>

    var result = [];
    for (var i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //5, ожидалось 0
    result[1](); //5, ожидалось 1
    result[2](); //5, ожидалось 2
</code>

Окружение при выходе из цикла:

<code>
    
    environment: {
        Environment: {
            result: [...],
            i: 5
        },
        outer: null
    }
</code>

Каждый раз, когда i увеличивается, обновляется область видимости, а она является общей для всех функций. 
Из-за этого любая из 5 функций, пытающихся получить доступ к i, возвращает 5, i === 5, когда цикл завершается.

Исправить можно использованием let вместо var, тк let находится в операторе блока и поэтому новая привязка идентификатора замыкания создается для каждой итерации в цикле for.

<code>

    var result = [];
    for (let i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //0
    result[1](); //1
    result[2](); //2
</code>

[Замыкания] https://learn.javascript.ru/closure <br/>
[Замыкания и циклы] https://ilyachalov.livejournal.com/163300.html
</details>

<details><summary><b>Что обозначает `this` в JavaScript?</b></summary>

<b><i>this</i></b> — это ключевое слово, используемое в JavaScript, которое имеет особое значение, зависящее от контекста в котором оно применяется. Контекст this меняется в зависимости от его использования.
Тот контекст, который имеет отношение к this, это не то же самое, что контекст выполнения.
Когда мы пользуемся ключевым словом this, мы обращаемся с его помощью к некоему объекту.

- если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, оно будет привязано к глобальному контексту, то есть — к объекту window в браузере;
- когда this используется внутри объекта, это ключевое слово ссылается на сам объект;
- применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что ключевое слово this относиться к тому объекту, в методе которого оно используется;
- в функции в строгом режиме this равен undefined;
- в стрелочной функции this будет таким, каким он был на момент создания стрелочной функции (захватывается из текущего контекста);
- вызов с помощью конструктора, используя ключевое слово new, значение this равно новосозданной функции;
- в событии относится к элементу, который получил событие;
- в call(), apply() и bind() this равно первому аргументу.

</details>

<details><summary><b>Что такое функции высшего порядка (Higher Order Functions)?</b></summary>
<b><i>Функции высшего порядка</i></b> — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.

Пример функции высшего порядка – аналог map:

<code>

    const strArray = ['JavaScript', 'Python', 'PHP', 'Java', 'C'];
    
    function mapForEach(arr, fn) {
        const newArray = [];
        for(let i = 0; i < arr.length; i++) {
            newArray.push(fn(arr[i]));
        }
        return newArray;
    }
    const lenArray = mapForEach(strArray, function(item) {
        return item.length;
    }); // выводит [ 10, 6, 3, 4, 1 ]
    console.log(lenArray);

</code>

[Функции высшего порядка] https://habr.com/ru/companies/ruvds/articles/428570/

</details>

<details><summary><b>Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?</b></summary>
Для <u>явного</u> используется Boolean();
Для <u>неявного</u>:
    - в логическогом контексте if(val) {...};
    - при применении логических операторов ||, &&, !.

|| и && производят булевое преобразование под капотом, но при этом всегда возвращают оригинальные значения.

<u>false</u> будут иметь: Boolean(''), 0, -0, NaN, null, undefined, false.
Всё остальное будет в значении true, даже включая [], {} и тд.
</details>

<details><summary><b>Методы строк в JavaScript?</b></summary>

**_slice(start, end)_** – возвращает часть строки от start до (не включая) end. Если аргумент end отсутствует, slice возвращает символы до конца строки.

**_substring(start, end)_** – возвращает часть строки между start и end (не включая) end. Это — почти то же, что и slice, но можно задавать start больше end.
Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами. Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

**_substr(start, length)_** – возвращает часть строки от start длины length.

**_trim()_** – убирает пробелы в начале и конце строки.

**_padStart(targetLength [, padString])_** – заполняет текущую строку другой строкой (несколько раз, если нужно) так, что итоговая строка достигает заданной длины. Заполнение осуществляется в начале (слева) текущей строки.

**_search(searchvalue)_** – ищет строку для указанного значения и возвращает позицию совпадения.
Значение поиска может быть строкой или регулярным выражением.
Этот метод возвращает -1, если совпадение не найдено.

**_indexOf(substr, pos)_** – ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений (не принимает регулярные выражения)

**_match()_** – ищет строку для соответствия регулярному выражению и возвращает совпадения в качестве объекта Array.
Если регулярное выражение не содержит модификатор g, метод match() возвращает только первое совпадение в строке.
Этот метод возвращает значение null, если совпадение не найдено.

**_split()_** – разделяет строку на массив по переданному разделителю. По умолчанию каждый символ.
</details>

<details><summary><b>Методы массивов в JavaScript?</b></summary>
<b><i>some()</i></b> – проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Он вернет значение true, если хотя бы один элемент совпадет с проверяемой функцией, и значение false — если нет.

<b><i>reduce()</i></b> – принимает функцию, которая имеет в качестве аргумента аккумулятор и значение. Он применяет функцию к аккумулятору и каждому значению массива, чтобы в результате вернуть только одно значение.

<b><i>every()</i></b> – проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Он вернет значение true, если каждый элемент совпадет с проверяемой функцией, и значение false — если нет.

<b><i>map()</i></b> – принимает функцию в качестве параметра и создает новый массив с результатом вызова указанной функции для каждого элемента массива. Он всегда будет возвращать одинаковое количество элементов.

<b><i>flat()</i></b> – принимает в качестве аргумента массив массивов и сглаживает вложенные массивы в массив верхнего уровня. Обратите внимание, что этот метод работает только для одного уровня.

<b><i>filter()</i></b> – принимает функцию в качестве параметра и возвращает новый массив, содержащий все элементы массива, для которого функция фильтрации передавалась в качестве аргумента, и возвращает ее со значением true.

<b><i>forEach()</i></b> – применяет функцию к каждому элементу массива.

<b><i>findIndex()</i></b> – принимает функцию в качестве параметра и в дальнейшем применяет ее к массиву. Он возвращает индекс найденного элемента, если элемент удовлетворяет условию проверяющей функции, переданной в качестве аргумента. Если не удовлетворяет, возвращается –1.

<b><i>find()</i></b> – принимает функцию в качестве аргумента и в дальнейшем применяет ее к массиву. Он возвращает значение элемента, найденного в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае оно возвращается со значением undefined.

<b><i>sort()</i></b> – принимает функцию в качестве параметра. Он сортирует элементы массива и возвращает их.

<b><i>concat()</i></b> – объединяет два или более массива/значения и возвращает новый массив.

<b><i>fill()</i></b> – заполняет все элементы массива одинаковым значением, от начального индекса (по умолчанию 0) до конечного индекса (по умолчанию array.length).

<b><i>includes()</i></b> – возвращает значение true, если массив содержит определенный элемент, и значение false — если нет.

<b><i>reverse()</i></b> – меняет порядок следования элементов в массиве на обратный. Первый элемент становится последним, а последний — первым.

<b><i>flatMap()</i></b> – применяет функцию к каждому элементу массива, а затем сглаживает результат в новый массив. Он объединяет метод flat() и метод map() в одну функцию.

<b><i>join()</i></b> – объединяет элементы массива в строку с переданным разделителем. По умолчанию ,.
[Методы массивов с примерами] https://habr.com/ru/companies/plarium/articles/483958/
</details>

<details><summary><b>Что такое чистая функция?</b></summary>
<b><i>Чистая функция</i></b> – это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Примеры побочных эффектов:

- Видоизменение входных параметров
- console.log
- HTTP вызовы (AJAX/fetch)
- Изменение в файловой системе
- Запросы DOM

[Чистые функции, примеры] https://frontend-stuff.com/blog/pure-and-impure-functions-in-js/ 
</details>

<details><summary><b>Разница между `.forEach()` и `.map()`?</b></summary>

Метод **_map()_** создает новый массив с результатами вызова предоставленной функции для каждого элемента в массиве, который вызывается.

Метод **_forEach()_** выполняет предоставленную функцию один раз для каждого элемента массива.

1. Возвращаемое значение
   
    _map()_ выделяет память и сохраняет значение return.

    _forEach()_ выбрасывает значение return и всегда возвращает undefined.
2. Возможность привязывать другие методы
   _map()_ можно привязывать к другим методам -  reduce(), sort(), filter() и т.д. 

    _forEach()_ возвращается undefined.

3. Изменчивость
   _map()_ возвращает совершенно новый массив с преобразованными элементами и тем же количеством данных. 

    В случае _forEach()_, даже если он вернется undefined, он изменит исходный массив с помощью callback. Поэтому что map() опирается на неизменность и forEach() является мутатором.

4. Скорость исполнения
   
    Во многих случаях _forEach()_ медленнее _map()_. Результаты для различных ОС и браузеров могут отличаться.

</details>

<details><summary><b>Разница между `.call()`, `.apply()` и `bind()`?</b></summary>

Метод <b><i>bind()</i></b> создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове. Функция при этом не вызывается.

Метод <b><i>call()</i></b> вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. В отличие от bind(), call() не копирует функцию. Он позволяет передавать объект в качестве this и любые аргументы, а затем немедленно вызывает функцию. Аргументы передаются через запятую.

Метод <b><i>apply()</i></b> вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива.

Методы <b><i>apply()</i></b> и <b><i>call()</i></b> практически идентичны при работе с выставлением значения this, за исключением того, что вы передаёте параметры функции в apply() как массив, в то время, как в call(), параметры передаются в индивидуальном порядке.
</details>

<details><summary><b>Почему в JS функции называют объектами первого класса?</b></summary>
Функции — это объект первого класса. Это означает, что функцию можно использовать так же, как и другие типы данных: сохранять в переменную, передавать аргументом и возвращать из функции.

Технически, функция — это объект JavaScript, у которого есть внутренний метод Call(), который добавляет возможность вызова функции.

[Функция как тип данных] https://doka.guide/js/function-as-datatype/
</details>

<details><summary><b>Как определить наличие свойства в объекте?</b></summary>
Есть 3 основных способа проверить, существует ли свойство. 

Первый способ — вызвать <b><i>object.hasOwnProperty(propName)</i></b>. Метод возвращает true, если propName существует в object, и false в противном случае. Обратите внимание, что hasOwnProperty() выполняет поиск только в пределах собственных свойств объекта.

Второй подход использует оператор <b><i>propName in object</i></b>. Оператор оценивается true для существующего свойства, и false в противном случае. Оператор in ищет наличие свойств как в собственных, так и в унаследованных свойствах объекта.

Третий подход – использовать <b><i>object.propName !== undefined</i></b> и сравнивать с undefined напрямую.
</details>

<details><summary><b>Что такое IIFE?</b></summary>
Немедленно вызываемая функция (Immediately Invoked Function Expression — IIFE) в JavaScript — это конструкция, позволяющая вызывать функцию непосредственно после ее определения.

<code>

      (function() {
         console.log('hello world')
      })();

</code>
</details>

<details><summary><b>Что такое псевдомассив `arguments`?</b></summary>
Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию (нестрелочную).

arguments – это не массив Array.

В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.

[Arguments] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/arguments
</details>

<details><summary><b>Разница между host-объектами и нативными объектами?</b></summary>
Нативные объекты — это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript, такие как String, Date, Math, RegExp, Object, Function и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как window, document, location, history, XMLHttpRequest, setTimeout, getElementsByTagName, querySelectorAll, ...
</details>

<details><summary><b>Почему результат сравнения 2х объектов это `false`?</b></summary>
<code>

      let a = {
         a: 1
      }
      let b = {
         a: 1
      }
      let c = a

      console.log(a === b) // false
      console.log(a === c) // true хм...
</code>
В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.
</details>

<details><summary><b>Что такое прототипное наследование? Как создать объект без прототипа?</b></summary>
Все объекты в JavaScript имеют свойство prototype, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.
</details>

<details><summary><b>Почему расширение нативных JavaScript-объектов это плохая практика?</b></summary>
Когда вы расширяете объект, вы меняете его поведение.

Изменение поведения объекта, которое будет использоваться только вашим собственным кодом, прекрасное. Но когда вы изменяете поведение чего-то, что также используется другим кодом, существует риск, что вы нарушите этот другой код.
Когда приходит применение методов к классам объектов и массивов в javascript, риск взлома чего-то очень высок из-за того, как работает javascript.


Если вам нужно настраивать поведение, гораздо лучше определить свой собственный класс (возможно, подкласс) вместо того, чтобы изменять базовый . Таким образом, вы ничего не сломаете.

Возможность изменять способ работы класса без его подклассификации является важной особенностью любого хорошего языка программирования, но его нужно использовать редко и с осторожностью.

Единственным оправданием расширения базовых прототипов могут являться лишь полифилы - эмуляторы новой функциональности (например, Array.forEach) для не поддерживающих её реализаций языка в старых веб-браузерах.
</details>
<details><summary><b>Что такое `NaN`? Как определить, что значение равно `NaN`?</b></summary>
NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением.

isNaN: если переменная не Number, то она преобразуется к нему, затем проверяется, является ли оно NaN.

Значение <u>true</u> вернут: NaN, undefined, {}, new Date().toString(), "blabla".

Number.isNaN: более надежная версия isNaN. В него безопасно передавать значения, которые обычно превращаются в NaN, но NaN не являются.

<u>true</u> возвращается только для числовых значений, имеющих NaN, тк приведения не будет и вернет true тольуо у NaN: NaN, Number.NaN, 0/0.
</details>

<details><summary><b>Что такое объектная обертка (Wrapper Objects)?</b></summary>
Во время вызова метода на примитивных значениях JS автоматически упаковывает значения в объект и вызывает метод на этом объекте.
После этого объект автоматиечски распаковывается на примитивное значение.

Для каждого примитивного типа в JS есть конструктор, который создает объект из примитивного значения. Именно он и вызывается, когда происходит упаковка.
Для распаковки используется valueOf(), который и возвращает примитивное значение объекта.
</details>

<details><summary><b>Как в JavaScript создать объект?</b></summary>

<b>Создание объектов с использованием синтаксиса литерала</b>

<code>

      const person = {
         firstName: 'Иван',
         lastName: 'Петров'
      };
</code>

<b>Создание объектов с использованием ключевого слова new:</b>
- Использование ключевого слова new со встроенной функцией конструктора объектов

  <code>

      const person = new Object();

      person.firstName = 'Иван';
      person.lastName = 'Петров';
</code>
Выглядит такой метод немного длиннее, чем литеральный. Кроме того, такая практика не рекомендуется, поскольку под капотом скрипта дополнительно будет происходить определение, является ли функция конструктора встроенной или определяемой пользователем.

- Использование new с функцией конструктора, определяемой пользователем

<code>

      function Person(fname, lname) {
        this.firstName = fname;
        this.lastName = lname;
      }
      const personOne = new Person('Иван', 'Петров');
      const personTwo = new Person('Петр', 'Иванов');
</code>

<b>Создание объектов с помощью Object.create()</b>

Метод Object.create() создает новый объект, используя существующий объект в качестве прототипа вновь созданного объекта.
Первый параметр - это обязательный объект, который служит прототипом нового создаваемого объекта. Второй параметр - это необязательный объект, который содержит свойства, добавляемые к новому объекту.

<code>

      const orgObject = { company: 'Моя компания' };
      const employee = Object.create(orgObject, { name: { value: 'Иван' } });

      console.log(employee.company);  // => "Моя компания"
      console.log(employee.name);  // => "Иван"
</code>

<b>Использование Object.assign() для создания новых объектов</b>

Метод Object.assign() используется для копирования значений всех собственных свойств из одного или нескольких исходных объектов в целевой объект. Он возвращает целевой объект.
Первый параметр - это объект, который он создаст и вернет. Остальные переданные ему объекты будут использоваться для копирования свойств в новый объект.

<code>

      const orgObject = { company: 'Моя компания' };
      const carObject = { carName: 'Ford' };

      const employee = Object.assign({}, orgObject, carObject);

      console.log(employee); // { carName: 'Ford', company: 'Моя компания' }
</code>
</details>

<details><summary><b>Для чего используется ключевое слово `new`?</b></summary>
Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

Допустим, у нас есть такой код:

<code>

      function Employee(name, position, yearHired){
         this.name = name
         this.position = position
         this.yearHired = yearHired
      }
      
      const emp = new Employee('Marko Polo', 'Software Development', 2017)
</code>

Создание объекта, определённого пользователем, требует два шага:

- Написать функцию, которая задаст тип объекта.
- Создать экземпляр объекта, используя new.

Чтобы определить новый тип объекта, создайте функцию, которая задаст его и имя и свойства.

Когда исполняется new Foo(...) , происходит следующее:

- Создаётся новый объект, наследующий Foo.prototype.
- Вызывается конструктор — функция Foo с указанными аргументами и this, привязанным к только что созданному объекту. new Foo эквивалентно new Foo(), то есть если аргументы не указаны, Foo вызывается без аргументов.
- Результатом выражения new становится объект, возвращённый конструктором. Если конструктор не возвращает объект явно, используется объект из п. 1. (Обычно конструкторы не возвращают значение, но они могут делать это, если нужно переопределить обычный процесс создания объектов.)

[Оператор new] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new
</details>

31. Операторы «И» и «ИЛИ» (`&&` и `||`)?
<details><summary><b>Для чего используется оператор двойного отрицания (`!!`)?</b></summary>
Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.

<code>

      console.log(!!null) // false
      console.log(!!undefined) // false
      console.log(!!'') // false
      console.log(!!0) // false
      console.log(!!NaN) // false
      console.log(!!' ') // true
      console.log(!!{}) // true
      console.log(!![]) // true
      console.log(!!1) // true
      console.log(!![].length) // false
</code>
</details>

33. Для чего используется оператор остатка (`%`)?
34. Как проверить, является ли значение массивом?
35. Как работает boxing/unboxing в JavaScript?
36. Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?
37. Разница между оператором `in` и методом `.hasOwnProperty()`?
38. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?
39. Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?
40. Что такое необъявленная переменная?
41. Как передаются параметры в функцию: по ссылке или по значению?
42. Что такое прототип объекта в JavaScript?
43. Как работает метод `Object.create()`?
44. Разниц между `Object.freeze()` и `Object.seal()`?
45. Разница между методами `.slice()` и `.splice()`?
46. Как работают методы `.find()`, `.findIndex()` и `.indexOf()`?
47. Плюсы и минусы использования `use strict`?
48. Разница между методами `.push()`, `.pop()`, `.shift()` и `.unshift()`?
49. Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?
50. Типы всплывающих окон в JavaScript?
51. Типы объектов JavaScript?
52. Парадигмы программирования в JavaScript?
53. Типы ошибок в JavaScript?
54. Разница между `typeof` и `instanceof`?
55. JavaScript статически, или динамически типизированный язык?
56. Что такое регулярное выражение (Regular Expression)?
57. Что такое рекурсия?
58. Что такое прототип (Prototype) объекта?
59. Какие методы используются в регулярных выражениях?
60. Что такое полифил (polyfill)?
61. Что такое `switch/case`? Правила использования `switch/case`?
62. Типы функций по способности принимать другие функции?
63. Что такое выражения (expression) и инструкции (statement) в JavaScript?
64. Разница между `.some()` и `.every()`?
65. Как сгенерировать случайное число в JavaScript?
66. Типы операторов в JavaScript?
67. Разница между параметром и аргументом функции?
68. Правила задания имён для переменных и функций в JavaScript?
69. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?
70. Для чего применяется метод `Array.from()`?
71. Назовите способы преобразования массива в объект?
72. Разница между `Object` и `Map`?
73. Что такое каррирование?
74. Для чего используются метод `Object.seal()`?
75. Для чего используется свойство `.dataset`?
76. Каким образом можно обмениваться кодом между файлами?
77. Как работает «сборщик мусора» в JavaScript?
78. Что такое утечки памяти?
79. Назовите основные типы утечек памяти в JavaScript?
80. Как работает контекст выполнения (execution context) в JavaScript?
81. Разница между примитивом и объектом?
---
