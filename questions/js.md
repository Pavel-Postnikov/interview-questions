<h3>
  <img src="../assets/JavaScript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3>


---
<details><summary><b>Типы данных в JavaScript?</b></summary>
В js есть 8 основных типов данных:
string, number, boolean, bigInt (int значения, которые слишком велики для number), object, null, undefined, symbol

Примитивные типы данных:
string, boolean, number, undefined

Сложные типы данных:
function, object

Объектный типы данных:
object, array, date
</details>
<details><summary><b>Разница между `==` и `===` (нестрогое/строгое равенство)?</b></summary>
Оператор <b>нестрогого равенства (==)</b> перед сравнением оператор равенства приводит обе величины к общему типу.
Это означает, что если типы данных сравниваемых операндов различны, то JavaScript автоматически преобразует один из операндов в тот же тип, что и другой, чтобы их можно было сравнить.

Правила для приведения типов в JavaScript:

- Если один из операндов является строкой, то второй операнд будет преобразован в строку.
- Если один из операндов является числом, другой операнд будет преобразован в число.
- Если один из операндов является булевым значением, он будет преобразован в число (true станет 1, а false — 0).
- Если один из операндов является объектом, а другой — примитивным значением, то перед сравнением объект будет
  преобразован в примитивное значение.
- Если один из операндов равен null или undefined, то, чтобы при сравнении вернулось true, второй тоже должен быть null
  или undefined. В противном случае возвращается false.

Оператор <b>строгого равенства (===)</b> проверяет равенство без приведения типов.
При сравнении переменных сначала проверяется, отличаются ли их типы. Если да, то возвращается false. Если типы
совпадают, то проверяется значение. Если значения одинаковы и не являются числами, возвращается true.
Наконец, если оба операнда — числа и не NaN, и у них одинаковое значение, то возвращается true. В противном случае —
false.

[Операторы сравнения] https://developer.mozilla.org/ru/docs/Web/JavaScript/Equality_comparisons_and_sameness
</details>
<details><summary><b>Что такое Strict mode в JavaScript?</b></summary>
Строгий режим или Strict — это функция, представленная в ECMAScript 5 (ES5), которая позволяет разработчикам использовать более строгий и безопасный вариант JavaScript.

При активации он применяет строгие правила и ограничения, помогая выявлять распространенные ошибки и повышать качество
кода. Строгий режим можно включить для каждого файла или функции, что позволяет разработчикам выбирать, где применять
его ограничения.

<b>Ограничения strict-режима</b>

- Объявление переменной. В строгом режиме вы должны объявить переменные с помощью ключевых слов var, let или const перед
  их использованием. В противном случае возникнет ошибка.
- Повторяющиеся имена параметров. Строгий режим запрещает функции с повторяющимися именами параметров. При попытке
  использовать их возникнет синтаксическая ошибка.
- Восьмеричные литералы (например, 0123) не допускаются в строгом режиме, и попытка их использования приведет к
  синтаксической ошибке. Вместо этого используйте префикс 0o для восьмеричных чисел.
- В строгом режиме попытка присвоить значение свойству, доступному только для чтения (например, глобальной переменной,
  такой как undefined, или свойству только для чтения встроенного объекта) приведет к ошибке TypeError.
- Оператор with запрещен в строгом режиме, так как он может привести к неоднозначному и трудно отлаживаемому коду.
- В строгом режиме eval имеет собственную область видимости, и переменные, объявленные внутри вызова eval, не попадают в
  окружающую область.
  -В нестрогом режиме значение this внутри функции, вызываемой без явного получателя (например, в качестве отдельной
  функции, а не метода), по умолчанию равно глобальному объекту. В строгом режиме this является undefined, что помогает
  предотвратить случайные изменения глобального объекта.

[Strict режим] https://tproger.ru/articles/ponimanie-strogogo-rezhima-javascript
</details>
<details><summary><b>Разница между function declaration и function expression?</b></summary>
1. this <br/>
1.1 <b><i>Обыкновенные функции</i></b> - значение this динамическое, зависит от того, как была вызвана функция:<br/>
        а) во время обычного выполнения this = глобальному объекту;<br/>
        б) во время выполнения ф-ии объекта значение = объекту, у которого был вызван метод;<br/>
        в) с помощью call, apply или bind this = 1му аргументу;<br/>
        г) с помощью конструктора используя ключевое слово new, значение this = новосозданной сущности  <br/>
    1.2 В <b><i>стрелочной ф-ии</i></b> значение this = this внешней ф-ии. Ф-ия не создает собственный контекст, а использует внешний.<br/>
<br/>
2. Конструкторы <br/>
2.1 <b><i>Обычная ф-ия</i></b> может легко создать объекты <br/>
2.2 <b><i>Стрелочная ф-ия</i></b> не имеет this и не может создавать объекты <br/>
<br/>
3. Объект arguments <br/>
3.1 Внутри тела <b><i>обычной ф-ии</i></b> существует специальный массив arguments, содержащий список аргументов, с которым ф-ия была вызвана. <br/>
3.2 В <b><i>стрелочной ф-ии</i></b> отсутствует arguments,  их значение будет браться из внешней ф-ии, но можно использовать деструктуризацию (...args).<br/>
<br/>
4. Неявный return <br/>
4.1 Только использование return вернет результат в <b><i>обычной ф-ии</i></b>.<br/>
4.2 Если <b><i>стрелочная ф-ия</i></b> содержит одну инструкцию и опущены фигурные скобки, то выражение вернется автоматически<br/>
<br/>
5. Методы <br/>
5.1 Нужно руками привязывать this к <b><i>обычной ф-ии</i></b>.<br/>
5.2 Метод с использованием <b><i>стрелочной ф-ии</i></b> привязывает this объекту класса.<br/>
<br/>
</details>
<details><summary><b>Разница между `null` и `undefined`?</b></summary>
<b><i>null</i></b> – явно присвоенное значение отсутствия, обозначает понятия «отсутствует», «ничего», «пусто» или «значение неизвестно».
В JavaScript null используется только для обозначения конца цепочки прототипов, чтобы показать, что следующий прототип отсутствует.

<b><i>undefined</i></b> – неявное отсутствие, переменную объявили, но не инициализировали.

<b><i>0</i></b> – самая "жирная" пустота, полноценное значение численной переменной.
</details>
<details><summary><b>Типы таймеров в JavaScript?</b></summary>
Функции-таймеры реализуются на уровне браузера, поэтому в разных браузерах их реализации отличаются.
<br/>В браузерах основные функции-таймеры относятся к интерфейсу Window, также связанному с некоторыми другими функциями и объектами. Этот интерфейс предоставляет ко всем своим элементам глобальный доступ в главной области видимости JavaScript. Вот почему функцию setTimeout можно выполнять непосредственно в консоли браузера.
<br/><br/>Для одноразового выполнения действий через промежуток времени предназначена функция <b><i>setTimeout()</i></b>. Она может принимать два параметра:

<code>var timerId = setTimeout(someFunction, period)</code>
<br/><br/>Если функция, для задержки которой используется setTimeout, принимает какие-либо аргументы, то можно
использовать оставшиеся аргументы самой функции setTimeout для переброски значений аргументов к отложенной функции.

<code>// Для: func(arg1, arg2, arg3, ...)<br/>
// Можно использовать: setTimeout(func, delay, arg1, arg2, arg3, ...)
</code>

Для остановки таймера применяется функция <b><i>clearTimeout()</i></b>.

Функции <b><i>setInterval()</i></b> и <b><i>clearInterval()</i></b> работают аналогично функциям setTimeout() и
clearTimeout() с той лишь разницей, что setInterval() постоянно выполняет определенную функцию через промежуток времени.

Метод <b><i>requestAnimationFrame()</i></b> действует аналогично setInterval() за тем исключением, что он больше заточен
под анимации, работу с графикой и имеет ряд оптимизаций, которые улучшают его производительность.

<code>function rotate() {
angle = (angle + 2)%360;
square.style.transform = "rotate(" + angle + "deg)";
window.requestAnimationFrame(rotate);
}</code>

В метод window.requestAnimationFrame() передается функция, которая будет вызываться определенное количество раз (обычно

60) в секунду. В данном случае в этот метод передается функция rotate, которая изменяет угол поворота блока на странице
    и затем обращается опять же к методу window.requestAnimationFrame(rotate).

[Статья 1] https://habr.com/ru/companies/piter/articles/426709/
[Статья 2] https://metanit.com/web/javascript/7.6.php
</details>
<details><summary><b>Что такое поднятие (Hoisting)?</b></summary>
<b>Поднятие</b> – механизм JS, в котором переменные и ф-ии передвигаются вверх своей области видимости перед тем, как код будет выполнен.

<b><i>var</i></b> – поднимает объявление и присваивает undefined;<br/>
<b><i>let</i></b> – при использовании до объявления выдаст ReferenceError, при использованиидо инициализации –
undefined;<br/>
<b><i>const</i></b> – до объявления и инициализации выдаст ReferenceError.<br/>

<i>Поднятие функций:</i>

- объявленные ф-ии <u>полностью</u> поднимаются вверх кода;
- функциональные выражения <u>не поднимаются</u>.

<i>Приоритет:</i>

- инициализация переменных имеет приоритет над объявлением ф-ий;
- объявление ф-ий имеет приоритет перед объявлением (<u>без инициализации!</u>) переменных.

<i>Поднятия классов:</i>

- объявления классов поднимаются как и ф-ии, но остаются неинициализированными до их объявления (ReferenceError);
- классовые выражения не поднимаются.

</details>
<details><summary><b>Что такое область видимости (Scope)?</b></summary>
<i>Область видимости</i> — это зона доступности переменных.
<b><i>Глобальная область видимости</i></b> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости.
JS в браузерах так устроен, что глобальные переменные попадают в объект window.

Если вы присваиваете значение переменной, которая ранее не была декларирована, то эта переменная автоматически
становится глобальной.

<b><i>Блочная область видимости</i></b> (let, const) ограничена программным блоком, обозначенным при помощи { и }.
Простейший пример такой области — это выражение внутри скобок:

<b><i>Функциональная область видимости</i></b> (var) — это область видимости в пределах тела функции. Можно сказать, что
она ограничена { и } функции.

[Область видимости] https://doka.guide/js/closures/
</details>
<details><summary><b>Разница между `var`, `let` и `const`?</b></summary>
<b><i>var</i></b> – функциональная область видимости, значение может быть переопределено и переобъявлено, объявленные значения поднимаются наверх;

<b><i>let</i></b> – блочная область видимости, не могут быть переобъявлены, но могут быть переопределены, поднимается
только объявление, но не значение (на верху undefined);

<b><i>const</i></b> – блочная область видимости, не могут быть переобъявлены и переопределены, поднимается наверх, не не
инициализируется, нужно инициализировать во время объявления.
Const не значит константное значение. Это значит константную ссылку на значение, а именно:

<u>НЕЛЬЗЯ:</u>

- переназначить постоянное значение;
- переназначить константный массив;
- переназначить константный объект.

<u>МОЖНО:</u>

- изменить элементы константного массива;
- изменить свойства константного объекта.

</details>

<details><summary><b>Что такое замыкание (Closure)?</b></summary>
<b><i>Замыкание</i></b> – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

Когда запускается функция, в начале ее вызова автоматически создается новое лексическое окружение для хранения локальных
переменных и параметров вызова.

В процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (
глобальное):Внутреннее лексическое окружение соответствует текущему выполнению. Внешнее лексическое окружение – это
глобальное лексическое окружение. У внутреннего лексического окружения есть ссылка на внешнее outer.

<b>Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во
внешнем, затем в следующем и так далее, до глобального.</b>

<code>

    const add = (function() {
        let counter = 0;
        return function() { 
            counter+=1;
            return counter;
        }
    })();
    add(); //counter = 1
    add(); //counter = 2
    add(); //counter = 3

</code>

<b>Замыкания и циклы</b>

<u>Для цикла у каждой итерации своё отдельное лексическое окружение</u>

<i>Работа цикла с лексическим окружением <u>без</u> вложенных функций</i>

На первой итерации для внутреннего содержимого (ограниченного фигурными скобками {}) цикла создается объект-лексическое
окружение с хранилищем локальных для цикла переменных и ссылкой на внешнее лексическое окружение. На следующей итерации
локальные переменные из лексического окружения предыдущей итерации копируются в хранилище нового лексического окружения,
созданного для текущей итерации цикла. И так далее.

Как только цикл перешел на очередную итерацию, в программе не остается ссылок на лексическое окружение прошлой итерации,
то есть становится недостижимым и поэтому автоматически уничтожается сборщиком мусора.

Таким образом, в памяти большую часть времени присутствует для цикла лишь одно лексическое окружение, относящееся к
текущей итерации цикла. После окончания работы цикла все объекты-лексические окружения, которые были созданы для
итераций цикла, оказываются уничтоженными сборщиком мусора.

<i>Работа цикла с <u>с</u> содержимым вложенной функций</i>

Для каждой итерации создается новое лексическое окружение. Однако, из-за того, что ссылка на лексическое окружение
каждой итерации записывается в скрытое свойство Environment вложенной в цикл функции, после окончания каждой итерации ее
лексическое окружение остается достижимым из программы и поэтому не унитожается сборщиком мусора.

<code>

    var result = [];
    for (var i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //5, ожидалось 0
    result[1](); //5, ожидалось 1
    result[2](); //5, ожидалось 2

</code>

Окружение при выходе из цикла:

<code>

    environment: {
        Environment: {
            result: [...],
            i: 5
        },
        outer: null
    }

</code>

Каждый раз, когда i увеличивается, обновляется область видимости, а она является общей для всех функций.
Из-за этого любая из 5 функций, пытающихся получить доступ к i, возвращает 5, i === 5, когда цикл завершается.

Исправить можно использованием let вместо var, тк let находится в операторе блока и поэтому новая привязка
идентификатора замыкания создается для каждой итерации в цикле for.

<code>

    var result = [];
    for (let i=0; i<5; i++) {
        result[i] = function() {
            console.log(i);
        }
    }
    result[0](); //0
    result[1](); //1
    result[2](); //2

</code>

[Замыкания] https://learn.javascript.ru/closure <br/>
[Замыкания и циклы] https://ilyachalov.livejournal.com/163300.html
</details>

<details><summary><b>Что обозначает `this` в JavaScript?</b></summary>

<b><i>this</i></b> — это ключевое слово, используемое в JavaScript, которое имеет особое значение, зависящее от
контекста в котором оно применяется. Контекст this меняется в зависимости от его использования.
Тот контекст, который имеет отношение к this, это не то же самое, что контекст выполнения.
Когда мы пользуемся ключевым словом this, мы обращаемся с его помощью к некоему объекту.

- если вы попытаетесь обратиться к ключевому слову this в глобальной области видимости, оно будет привязано к
  глобальному контексту, то есть — к объекту window в браузере;
- когда this используется внутри объекта, это ключевое слово ссылается на сам объект;
- применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что
  ключевое слово this относиться к тому объекту, в методе которого оно используется;
- в функции в строгом режиме this равен undefined;
- в стрелочной функции this будет таким, каким он был на момент создания стрелочной функции (захватывается из текущего
  контекста);
- вызов с помощью конструктора, используя ключевое слово new, значение this равно новосозданной функции;
- в событии относится к элементу, который получил событие;
- в call(), apply() и bind() this равно первому аргументу.

</details>

<details><summary><b>Что такое функции высшего порядка (Higher Order Functions)?</b></summary>
<b><i>Функции высшего порядка</i></b> — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.

Пример функции высшего порядка – аналог map:

<code>

    const strArray = ['JavaScript', 'Python', 'PHP', 'Java', 'C'];
    
    function mapForEach(arr, fn) {
        const newArray = [];
        for(let i = 0; i < arr.length; i++) {
            newArray.push(fn(arr[i]));
        }
        return newArray;
    }
    const lenArray = mapForEach(strArray, function(item) {
        return item.length;
    }); // выводит [ 10, 6, 3, 4, 1 ]
    console.log(lenArray);

</code>

[Функции высшего порядка] https://habr.com/ru/companies/ruvds/articles/428570/

</details>

<details><summary><b>Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?</b></summary>
Для <u>явного</u> используется Boolean();
Для <u>неявного</u>:
    - в логическогом контексте if(val) {...};
    - при применении логических операторов ||, &&, !.

|| и && производят булевое преобразование под капотом, но при этом всегда возвращают оригинальные значения.

<u>false</u> будут иметь: Boolean(''), 0, -0, NaN, null, undefined, false.
Всё остальное будет в значении true, даже включая [], {} и тд.
</details>

<details><summary><b>Методы строк в JavaScript?</b></summary>

**_slice(start, end)_** – возвращает часть строки от start до (не включая) end. Если аргумент end отсутствует, slice
возвращает символы до конца строки.

**_substring(start, end)_** – возвращает часть строки между start и end (не включая) end. Это — почти то же, что и
slice, но можно задавать start больше end.
Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами. Отрицательные
значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

**_substr(start, length)_** – возвращает часть строки от start длины length.

**_trim()_** – убирает пробелы в начале и конце строки.

**_padStart(targetLength [, padString])_** – заполняет текущую строку другой строкой (несколько раз, если нужно) так,
что итоговая строка достигает заданной длины. Заполнение осуществляется в начале (слева) текущей строки.

**_search(searchvalue)_** – ищет строку для указанного значения и возвращает позицию совпадения.
Значение поиска может быть строкой или регулярным выражением.
Этот метод возвращает -1, если совпадение не найдено.

**_indexOf(substr, pos)_** – ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой
располагается совпадение, либо -1 при отсутствии совпадений (не принимает регулярные выражения)

**_match()_** – ищет строку для соответствия регулярному выражению и возвращает совпадения в качестве объекта Array.
Если регулярное выражение не содержит модификатор g, метод match() возвращает только первое совпадение в строке.
Этот метод возвращает значение null, если совпадение не найдено.

**_split()_** – разделяет строку на массив по переданному разделителю. По умолчанию каждый символ.
</details>

<details><summary><b>Методы массивов в JavaScript?</b></summary>
<b><i>some()</i></b> – проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Он вернет значение true, если хотя бы один элемент совпадет с проверяемой функцией, и значение false — если нет.

<b><i>reduce()</i></b> – принимает функцию, которая имеет в качестве аргумента аккумулятор и значение. Он применяет
функцию к аккумулятору и каждому значению массива, чтобы в результате вернуть только одно значение.

<b><i>every()</i></b> – проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Он
вернет значение true, если каждый элемент совпадет с проверяемой функцией, и значение false — если нет.

<b><i>map()</i></b> – принимает функцию в качестве параметра и создает новый массив с результатом вызова указанной
функции для каждого элемента массива. Он всегда будет возвращать одинаковое количество элементов.

<b><i>flat()</i></b> – принимает в качестве аргумента массив массивов и сглаживает вложенные массивы в массив верхнего
уровня. Обратите внимание, что этот метод работает только для одного уровня.

<b><i>filter()</i></b> – принимает функцию в качестве параметра и возвращает новый массив, содержащий все элементы
массива, для которого функция фильтрации передавалась в качестве аргумента, и возвращает ее со значением true.

<b><i>forEach()</i></b> – применяет функцию к каждому элементу массива.

<b><i>findIndex()</i></b> – принимает функцию в качестве параметра и в дальнейшем применяет ее к массиву. Он возвращает
индекс найденного элемента, если элемент удовлетворяет условию проверяющей функции, переданной в качестве аргумента.
Если не удовлетворяет, возвращается –1.

<b><i>find()</i></b> – принимает функцию в качестве аргумента и в дальнейшем применяет ее к массиву. Он возвращает
значение элемента, найденного в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае оно
возвращается со значением undefined.

<b><i>sort()</i></b> – принимает функцию в качестве параметра. Он сортирует элементы массива и возвращает их.

<b><i>concat()</i></b> – объединяет два или более массива/значения и возвращает новый массив.

<b><i>fill()</i></b> – заполняет все элементы массива одинаковым значением, от начального индекса (по умолчанию 0) до
конечного индекса (по умолчанию array.length).

<b><i>includes()</i></b> – возвращает значение true, если массив содержит определенный элемент, и значение false — если
нет.

<b><i>reverse()</i></b> – меняет порядок следования элементов в массиве на обратный. Первый элемент становится
последним, а последний — первым.

<b><i>flatMap()</i></b> – применяет функцию к каждому элементу массива, а затем сглаживает результат в новый массив. Он
объединяет метод flat() и метод map() в одну функцию.

<b><i>join()</i></b> – объединяет элементы массива в строку с переданным разделителем. По умолчанию ,.
[Методы массивов с примерами] https://habr.com/ru/companies/plarium/articles/483958/
</details>

<details><summary><b>Что такое чистая функция?</b></summary>
<b><i>Чистая функция</i></b> – это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Примеры побочных эффектов:

- Видоизменение входных параметров
- console.log
- HTTP вызовы (AJAX/fetch)
- Изменение в файловой системе
- Запросы DOM

[Чистые функции, примеры] https://frontend-stuff.com/blog/pure-and-impure-functions-in-js/
</details>

<details><summary><b>Разница между `.forEach()` и `.map()`?</b></summary>

Метод **_map()_** создает новый массив с результатами вызова предоставленной функции для каждого элемента в массиве,
который вызывается.

Метод **_forEach()_** выполняет предоставленную функцию один раз для каждого элемента массива.

1. Возвращаемое значение

   _map()_ выделяет память и сохраняет значение return.

   _forEach()_ выбрасывает значение return и всегда возвращает undefined.
2. Возможность привязывать другие методы
   _map()_ можно привязывать к другим методам - reduce(), sort(), filter() и т.д.

   _forEach()_ возвращается undefined.

3. Изменчивость
   _map()_ возвращает совершенно новый массив с преобразованными элементами и тем же количеством данных.

   В случае _forEach()_, даже если он вернется undefined, он изменит исходный массив с помощью callback. Поэтому что
   map() опирается на неизменность и forEach() является мутатором.

4. Скорость исполнения

   Во многих случаях _forEach()_ медленнее _map()_. Результаты для различных ОС и браузеров могут отличаться.

</details>

<details><summary><b>Разница между `.call()`, `.apply()` и `bind()`?</b></summary>

Метод <b><i>bind()</i></b> создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this
предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в
привязанную функцию аргументами при её вызове. Функция при этом не вызывается.

Метод <b><i>call()</i></b> вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. В
отличие от bind(), call() не копирует функцию. Он позволяет передавать объект в качестве this и любые аргументы, а затем
немедленно вызывает функцию. Аргументы передаются через запятую.

Метод <b><i>apply()</i></b> вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива.

Методы <b><i>apply()</i></b> и <b><i>call()</i></b> практически идентичны при работе с выставлением значения this, за
исключением того, что вы передаёте параметры функции в apply() как массив, в то время, как в call(), параметры
передаются в индивидуальном порядке.
</details>

<details><summary><b>Почему в JS функции называют объектами первого класса?</b></summary>
Функции — это объект первого класса. Это означает, что функцию можно использовать так же, как и другие типы данных: сохранять в переменную, передавать аргументом и возвращать из функции.

Технически, функция — это объект JavaScript, у которого есть внутренний метод Call(), который добавляет возможность
вызова функции.

[Функция как тип данных] https://doka.guide/js/function-as-datatype/
</details>

<details><summary><b>Как определить наличие свойства в объекте?</b></summary>
Есть 3 основных способа проверить, существует ли свойство. 

Первый способ — вызвать <b><i>object.hasOwnProperty(propName)</i></b>. Метод возвращает true, если propName существует в
object, и false в противном случае. Обратите внимание, что hasOwnProperty() выполняет поиск только в пределах
собственных свойств объекта.

Второй подход использует оператор <b><i>propName in object</i></b>. Оператор оценивается true для существующего
свойства, и false в противном случае. Оператор in ищет наличие свойств как в собственных, так и в унаследованных
свойствах объекта.

Третий подход – использовать <b><i>object.propName !== undefined</i></b> и сравнивать с undefined напрямую.
</details>

<details><summary><b>Что такое IIFE?</b></summary>
Немедленно вызываемая функция (Immediately Invoked Function Expression — IIFE) в JavaScript — это конструкция, позволяющая вызывать функцию непосредственно после ее определения.

<code>

      (function() {
         console.log('hello world')
      })();

</code>
</details>

<details><summary><b>Что такое псевдомассив `arguments`?</b></summary>
Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию (нестрелочную).

arguments – это не массив Array.

В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких
особых методов у него нет, и методы массивов он тоже не поддерживает.

[Arguments] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/arguments
</details>

<details><summary><b>Разница между host-объектами и нативными объектами?</b></summary>
Нативные объекты — это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript, такие как String, Date, Math, RegExp, Object, Function и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как window, document, location, history,
XMLHttpRequest, setTimeout, getElementsByTagName, querySelectorAll, ...
</details>

<details><summary><b>Почему результат сравнения 2х объектов это `false`?</b></summary>
<code>

      let a = {
         a: 1
      }
      let b = {
         a: 1
      }
      let c = a

      console.log(a === b) // false
      console.log(a === c) // true хм...

</code>
В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.
</details>

<details><summary><b>Что такое прототипное наследование? Как создать объект без прототипа?</b></summary>
Все объекты в JavaScript имеют свойство prototype, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.
</details>

<details><summary><b>Почему расширение нативных JavaScript-объектов это плохая практика?</b></summary>
Когда вы расширяете объект, вы меняете его поведение.

Изменение поведения объекта, которое будет использоваться только вашим собственным кодом, прекрасное. Но когда вы
изменяете поведение чего-то, что также используется другим кодом, существует риск, что вы нарушите этот другой код.
Когда приходит применение методов к классам объектов и массивов в javascript, риск взлома чего-то очень высок из-за
того, как работает javascript.

Если вам нужно настраивать поведение, гораздо лучше определить свой собственный класс (возможно, подкласс) вместо того,
чтобы изменять базовый . Таким образом, вы ничего не сломаете.

Возможность изменять способ работы класса без его подклассификации является важной особенностью любого хорошего языка
программирования, но его нужно использовать редко и с осторожностью.

Единственным оправданием расширения базовых прототипов могут являться лишь полифилы - эмуляторы новой функциональности (
например, Array.forEach) для не поддерживающих её реализаций языка в старых веб-браузерах.
</details>
<details><summary><b>Что такое `NaN`? Как определить, что значение равно `NaN`?</b></summary>
NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением.

isNaN: если переменная не Number, то она преобразуется к нему, затем проверяется, является ли оно NaN.

Значение <u>true</u> вернут: NaN, undefined, {}, new Date().toString(), "blabla".

Number.isNaN: более надежная версия isNaN. В него безопасно передавать значения, которые обычно превращаются в NaN, но
NaN не являются.

<u>true</u> возвращается только для числовых значений, имеющих NaN, тк приведения не будет и вернет true тольуо у NaN:
NaN, Number.NaN, 0/0.
</details>

<details><summary><b>Что такое объектная обертка (Wrapper Objects / wraping-unwraping / boxing-unboxing)?</b></summary>
Во время вызова метода на примитивных значениях JS автоматически упаковывает значения в объект и вызывает метод на этом объекте.
После этого объект автоматиечски распаковывается на примитивное значение.

Для каждого примитивного типа в JS есть конструктор, который создает объект из примитивного значения. Именно он и
вызывается, когда происходит упаковка.
Для распаковки используется valueOf(), который и возвращает примитивное значение объекта.
</details>

<details><summary><b>Как в JavaScript создать объект?</b></summary>

<b>Создание объектов с использованием синтаксиса литерала</b>

<code>

      const person = {
         firstName: 'Иван',
         lastName: 'Петров'
      };

</code>

<b>Создание объектов с использованием ключевого слова new:</b>

- Использование ключевого слова new со встроенной функцией конструктора объектов

  <code>

      const person = new Object();

      person.firstName = 'Иван';
      person.lastName = 'Петров';

</code>
Выглядит такой метод немного длиннее, чем литеральный. Кроме того, такая практика не рекомендуется, поскольку под капотом скрипта дополнительно будет происходить определение, является ли функция конструктора встроенной или определяемой пользователем.

- Использование new с функцией конструктора, определяемой пользователем

<code>

      function Person(fname, lname) {
        this.firstName = fname;
        this.lastName = lname;
      }
      const personOne = new Person('Иван', 'Петров');
      const personTwo = new Person('Петр', 'Иванов');

</code>

<b>Создание объектов с помощью Object.create()</b>

Метод Object.create() создает новый объект, используя существующий объект в качестве прототипа вновь созданного объекта.
Первый параметр - это обязательный объект, который служит прототипом нового создаваемого объекта. Второй параметр - это
необязательный объект, который содержит свойства, добавляемые к новому объекту.

<code>

      const orgObject = { company: 'Моя компания' };
      const employee = Object.create(orgObject, { name: { value: 'Иван' } });

      console.log(employee.company);  // => "Моя компания"
      console.log(employee.name);  // => "Иван"

</code>

<b>Использование Object.assign() для создания новых объектов</b>

Метод Object.assign() используется для копирования значений всех собственных свойств из одного или нескольких исходных
объектов в целевой объект. Он возвращает целевой объект.
Первый параметр - это объект, который он создаст и вернет. Остальные переданные ему объекты будут использоваться для
копирования свойств в новый объект.

<code>

      const orgObject = { company: 'Моя компания' };
      const carObject = { carName: 'Ford' };

      const employee = Object.assign({}, orgObject, carObject);

      console.log(employee); // { carName: 'Ford', company: 'Моя компания' }

</code>
</details>

<details><summary><b>Для чего используется ключевое слово `new`?</b></summary>
Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

Допустим, у нас есть такой код:

<code>

      function Employee(name, position, yearHired){
         this.name = name
         this.position = position
         this.yearHired = yearHired
      }
      
      const emp = new Employee('Marko Polo', 'Software Development', 2017)

</code>

Создание объекта, определённого пользователем, требует два шага:

- Написать функцию, которая задаст тип объекта.
- Создать экземпляр объекта, используя new.

Чтобы определить новый тип объекта, создайте функцию, которая задаст его и имя и свойства.

Когда исполняется new Foo(...) , происходит следующее:

- Создаётся новый объект, наследующий Foo.prototype.
- Вызывается конструктор — функция Foo с указанными аргументами и this, привязанным к только что созданному объекту. new
  Foo эквивалентно new Foo(), то есть если аргументы не указаны, Foo вызывается без аргументов.
- Результатом выражения new становится объект, возвращённый конструктором. Если конструктор не возвращает объект явно,
  используется объект из п. 1. (Обычно конструкторы не возвращают значение, но они могут делать это, если нужно
  переопределить обычный процесс создания объектов.)

[Оператор new] https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new
</details>

<details><summary><b>Операторы «И» и «ИЛИ» (`&&` и `||`)?</b></summary>
Оператор && находит и возвращает первое ложное значение, либо последний операнд, когда все значения истинные.

Оператор || возвращает первое истинное значение и как только находится, дальнейшая проверка не выполняется.

<code>

        console.log(false && 2021 && 'string') //false
        console.log(2021 && {} && 'string') //'string'
        console.log(true && null && 'string') //null

        console.log(false || 2021 || 'string') //2021

</code>
</details>
<details><summary><b>Для чего используется оператор двойного отрицания (`!!`)?</b></summary>
Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.

<code>

      console.log(!!null) // false
      console.log(!!undefined) // false
      console.log(!!'') // false
      console.log(!!0) // false
      console.log(!!NaN) // false
      console.log(!!' ') // true
      console.log(!!{}) // true
      console.log(!![]) // true
      console.log(!!1) // true
      console.log(!![].length) // false

</code>
</details>

<details><summary><b>Для чего используется оператор остатка (`%`)?</b></summary>
Этот оператор возвращает остаток от деления первого операнда на второй
</details>

<details><summary><b>Как проверить, является ли значение массивом?</b></summary>
Для этого следует использовать метод Array.isArray:

<code>

        console.log(Array.isArray(5)) // false
        console.log(Array.isArray('')) // false
        console.log(Array.isArray()) // false
        console.log(Array.isArray(null)) // false
        console.log(Array.isArray( {length: 5 })) // false
        console.log(Array.isArray([])) // true

</code>

Если среда, в которой Вы работаете, не поддерживает данный метод, можете использовать такой полифил:

<code>

        function isArray(value){
            return Object.prototype.toString.call(value) === '[object Array]'
        }

</code>
</details>

<details><summary><b>Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?</b></summary>

Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество
мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком
является то, что мы вынуждены выделять дополнительную память для сохранения результатов.

<code>

    function memoize(fn){
        const cache = {}
        return function(param){
            if(cache[param]){
                console.log('cached')
                return cache[param]
            } else{
                let result = fn(param)
                cache[param] = result
                console.log('not cached')
                return result
            }
        }
    }

    const toUpper = (str = '') => str.toUpperCase()

    const toUpperMemoized = memoize(toUpper)

    toUpperMemoized('abcdef')
    toUpperMemoized('abcdef') // не выполнится

</code>
Мы реализовали функцию мемоизации с одним аргументом. Сделаем ее «мультиаргументной»:
<code>

    const slice = Array.prototype.slice
    function memoize(fn){
        const cache = {}
        return (...args) => {
            const params = slice.call(args)
            console.log(params)
            if(cache[params]){
                console.log('cached')
                return cache[params]
            } else{
                let result = fn(...args)
                cache[params] = result
                console.log('not cached')
                return result
            }
        }
    }
    const makeFullName = (fName, lName) => `${fName} ${lName}`
    const reduceAdd = (numbers, startValue = 0) => numbers.reduce((total, cur) => total + cur, startValue)

    const memoizedFullName = memoize(makeFullName)
    const memoizeReduceAdd = memoize(reduceAdd)

    memoizedFullName('Marko', 'Polo')
    memoizedFullName('Marko', 'Polo') // не выполнится

    memoizeReduceAdd([1,2,3,4],5)
    memoizeReduceAdd([1,2,3,4],5) // не выполнится

</code>
</details>

<details><summary><b>Разница между оператором `in` и методом `.hasOwnProperty()`?</b></summary>
Отличие состоит в том, что оператор <u>«in»</u> проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод <u>hasOwnProperty</u> — только в объекте.
<code>

    console.log('prop' in o) // true
    console.log('toString' in o) // true
    
    console.log(o.hasOwnProperty('prop')) // true
    console.log(o.hasOwnProperty('toString')) // false

</code>
</details>

<details><summary><b>Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?</b></summary>
При копировании объектов или массивов с использованием spread оператора JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).
Непримитивные типы данных, такие как массивы и объекты, хранятся по ссылке. Так как копирование происходит только на один уровень вглубь, то при копировании массива происходит копирование ссылок на старые объекты в новый массив.

Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (
deep) или полное копирование данных.
JavaScript не содержит функций для глубокого копирования, вариант сделать глубокую копию — сериализовать структуру в
JSON и тут же распарсить (JSON.parse(JSON.stringify(*item*))).
</details>

<details><summary><b>Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?</b></summary>
В JavaScript мы можем вызывать цепочку методов:

car.start().drive()

Это довольно удобный подход, в отличие от традиционного способа написания кода:

car.start();

car.drive();

Но использовать цепочку методов можно только в том случае, когда каждый метод возвращает сам объект. То есть, реализация
должна иметь следующий вид:

<code>

    const car = {
        start: function() {
        console.log('start')
        return this
    },
    drive: function() {
        console.log('drive')
        return this
        }
    }

</code>

Важно знать, что цепочки методов не могут быть сформированы для стрелочных функций, потому что в стрелочных функциях
this является методов объекта, а не его экземпляром.

Если метод возвращает набор значений, очевидно, нам придется использовать для следующих за ним методов аргументы, что
автоматически делает невозможным использование цепочки методов:
</details>

<details><summary><b>Что такое необъявленная переменная?</b></summary>
Необъявленные переменные - это те, которые не существуют в программе и не объявлены. Если программа пытается прочитать значение необъявленной переменной, то возникает ошибка во время выполнения.
</details>

<details><summary><b>Как передаются параметры в функцию: по ссылке или по значению?</b></summary>

1) <b>Передача параметров по значению в функцию</b>

Строки, числа, флаги передаются в функцию по значению.
То есть при передаче параметра в функцию если параметр (строка, число, флаг) то для такого параметра создается копия и
внутри функции мы работаем с копией параметра.

При выходе из функции:

- параметр не меняет значение
- копия параметра меняет значение, но разрушается при выходе из функции

2) <b>Передача параметров по ссылке в функцию</b>

Объекты и массивы передаются в функцию по ссылке.
То есть при передаче параметра в функцию если параметр (объект, массив) то такой параметр передается внутрь функции и мы
работаем с этим параметром.

При выходе из функции:

- параметр меняет значение

</details>

<details><summary><b>Что такое прототип объекта в JavaScript?</b></summary>
Прототип – механизм, с помощью которого объекты JS наследуют свойства друг от друга.

_proto_ – это почти всегда объект. Разные proto разных по "типу" объектов – совершенно независимые разные объекты.
У "одинаковых" по типу объектов _proto_ равны.

У любого объекта есть _proto_. Чтобы понимать, чему оно равно, нужно точно знать, с помощью какой функции конструктора
создан данный объект (new XXX()).

_proto_ любого объекта ссылается на prototype класса, с помощью которого этот объект был создан.
let channel = new YoutubeChannel() //chanel._proto_ === YoutubeChannel.prototype

[Прототипы] https://youtu.be/b55hiUlhAzI?si=FIbyUrH8Kv0NRhEf
</details>

<details><summary><b>Как работает метод `Object.create()`?</b></summary>
Метод Object.create() создает новый объект, используя существующий объект в качестве прототипа вновь созданного объекта.
Первый параметр - это обязательный объект, который служит прототипом нового создаваемого объекта. Второй параметр - это необязательный объект, который содержит свойства, добавляемые к новому объекту.

<code>

      const orgObject = { company: 'Моя компания' };
      const employee = Object.create(orgObject, { name: { value: 'Иван' } });

      console.log(employee.company);  // => "Моя компания"
      console.log(employee.name);  // => "Иван"

</code>

</details>

<details><summary><b>Разница между `Object.freeze()` и `Object.seal()`?</b></summary>
Object.seal() позволяет изменять существующие свойства объекта. Он предотвращает удаление существующих свойств, но не может предотвратить их внешние изменения.

Object.freeze() не позволяет этого. Это делает объект невосприимчивым ко всему, даже небольшие изменения не могут быть
внесены.
</details>

<details><summary><b>Разница между методами `.slice()` и `.splice()`?</b></summary>
Метод <b><i>slice()</i></b> копирует заданную часть массива и возвращает её в виде совершенно нового массива. Этот метод вообще не трогает оригинальный массив.

array.slice(from, until);

Метод <b><i>splice()</i></b> изменяет массив, добавляя или удаляя элементы в нем. Если мы не указываем второй параметр,
то будут удалены все элементы, начиная с заданного значения index.

array.splice(index, number of elements);

Для добавления элементов нам нужно указать 3, 4 и 5й параметры (в зависимости от того, сколько мы хотим добавить) методу
splice():

array.splice(index, number of elements, element, element);

</details>
<details><summary><b>Как работают методы `.find()`, `.findIndex()` и `.indexOf()`?</b></summary>
Методы <b><i>indexOf()</i></b> и <b><i>lastIndexOf()</i></b> позволяют вернуть позиции первого и последнего вхождений заданного элемента в массиве.

Метод <b><i>find()</i></b> возвращает элемент массива, соответствующий заданному критерию. Критерий формируется в
специальной функции или лямбда-функцией.

Метод <b><i>findIndex()</i></b> возвращает позицию (индекс) элемента, удовлетворяющего заданному критерию. Критерий
определяется заданной функцией или лямбда-функцией. Метод подобен методу find() только вместо самого элемента
возвращается его позиция.
</details>

<details><summary><b>Плюсы и минусы использования `use strict`?</b></summary>
‘use strict’ это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

Преимущества:

- не позволяет случайно создавать глобальные переменные.
- любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- при попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не
  произошло).
- требует, чтобы имена параметров функции были уникальными.
- this в глобальной области видимости равно undefined.
- перехватывает распространенные ошибки, выдавая исключения.
- исключает неочевидные особенности языка.

Недостатки:

- нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- нет доступа к function.caller и function.arguments.
- объединение скриптов, написанных в строгом режиме может вызвать проблемы.

</details>

<details><summary><b>Разница между методами `.push()`, `.pop()`, `.shift()` и `.unshift()`?</b></summary>
<b><i>push()</i></b> – добавляет элемент в конец массива и возвращает длину нового массива;
<b><i>pop()</i></b> – удаляет последний элемент из массива и возвращает удаленное значение;
<b><i>shift()</i></b> – удаляет первый элемент из массива и возвращает удаленное значение;
<b><i>unshift()</i></b> – добавляет элемент в начало массива и возвращает длину нового массива;
</details>

<details><summary><b>Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?</b></summary>
Плюсы: 
- легко тестировать;
- безопаснее использовать

Минусы:

- большой расход памяти

Достичь иммутабельности можно с помощью Object.freeze().
</details>

<details><summary><b>Типы всплывающих окон в JavaScript?</b></summary>
Функция <b>alert</b> позволяет вывести какую-либо информацию во всплывающем окне в браузере. К таким окнам нельзя добавить стили и разукрасить их.

Функция <b>confirm</b> открывает всплывающее окно с определенным вопросом и двумя кнопками: Ок и Отмена. Полученные
данные из окна можно проверить в условном операторе и в зависимости от них выполнить код.

Метод <b>prompt</b> получает информацию от пользователя. Полученные данные можно поместить в переменную.
</details>

Типы объектов JavaScript?
<details><summary><b>Парадигмы программирования в JavaScript?</b></summary>

Парадигмы императивного стиля:

- Процедурное программирование

Это парадигма, в которой последовательные команды собираются в подпрограммы.

- Объектно-ориентированное программирование

ООП (объектно-ориентированное программирование) — парадигма, в которой сущности в программе представляются в виде
объектов.

Парадигмы декларативного стиля

- Логическое программирование

Его суть заключается в том, чтобы, используя математические доказательства и законы логики, решать бизнес-задачи.

- Функциональное программирование

В этой парадигме понятие функции близко к математическому понятию функции. То есть это штука, которая как-то преобразует
входные данные.
Особенность функции в этой парадигме в том, что она должна быть чистой, то есть должна зависеть только от аргументов и
не может иметь никаких побочных эффектов.

[Парадигмы программирования] https://doka.guide/js/programming-paradigms/
</details>

<details><summary><b>Типы ошибок в JavaScript?</b></summary>
Существует семь встроенных видов ошибок, также можно создать свои собственные. Встроенные ошибки генерируются самим движком JavaScript при выполнении программы, а пользовательские — создаются с помощью конструктора Error. Оба типа ошибок можно ловить в конструкции try...catch.

<b>Error</b> – общий конструктор ошибок;

Вызов конструктора возвращает объект ошибки со следующими свойствами:

- message представляет человекопонятное описание ошибки для встроенных типов (SyntaxError, TypeError и так далее) и
  переданное в конструктор значение для общего типа Error.
- name — имя типа (класса) ошибки.

Встроенные ошибки
<b>SyntaxError</b>

Чаще всего встречаются опечатки — неправильные названия методов, лишние или отсутствующие точки с запятой или скобочки и
так далее. Такой тип ошибок называется «синтаксическим», SyntaxError.

**ReferenceError**

Если попытаться обратиться к несуществующей переменной, произойдёт ошибка ReferenceError.

**TypeError**

Если попытаться обратиться к несуществующему свойству, произойдёт ошибка TypeError.

**RangeError**

Ошибка для значений, которые выходят за диапазон допустимого.

**URIError**

Этот тип ошибок возникает при неправильном использовании обработки URI.

**EvalError**

EvalError представляет ошибку, возникающую в глобальной функции eval(). Эта ошибка в настоящее время не используется и
остаётся для совместимости с предыдущими версиями JavaScript.

**InternalError (не стандарт)**

Ошибка внутри движка JavaScript. Не является стандартом и почти не используется.

</details>

<details><summary><b>Разница между `typeof` и `instanceof`?</b></summary>

Оператор **typeof** используется, в основном, для того, чтобы узнать тип примитивного значения.

Исключения:
Typeof document.all всегда возвращает undefined, даже если он определен во всех браузерах.

Оператор **instanceof** проверяет, появляется ли свойство прототипа конструктора где-либо в цепочке прототипов объекта.
Это означает, что мы можем использовать его, чтобы проверить, является ли объект конструктором из данного класса или
функции-конструктора.

Он возвращает true, если объект является экземпляром класса или функции-конструктора, и false в противном случае.

</details>

<details><summary><b>JavaScript статически или динамически типизированный язык?</b></summary>
JS – динамически типизированный яп.

Динамическая проверка типов — это процесс подтверждения типобезопасности программы во время её выполнения.
</details>

<details><summary><b>Что такое регулярное выражение (Regular Expression)?</b></summary>
    Регулярные выражения - это шаблоны, используемые для сопоставления последовательностей символов в строках. В JavaScript регулярные выражения также являются объектами.

[Регулярные выражения] https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_expressions
</details>
<details><summary><b>Что такое рекурсия?</b></summary>

Рекурсия (recursion) — это поведение функции, при котором она вызывает сама себя. Такие функции называются рекурсивными. В отличие от цикла, они не просто повторяются несколько раз, а работают «внутри» друг друга.
</details>

<details><summary><b>Какие методы используются в регулярных выражениях?</b></summary>

Метод _**str.match(regexp)**_ ищет совпадения с regexp в строке str.

Метод _**str.matchAll(regexp)**_ – «новый, улучшенный» вариант метода str.match.
Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.

_**str.split(regexp|substr, limit)**_ разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.

Метод _**str.search(regexp)**_ возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет.

Метод _**regexp.exec(str)**_ ищет совпадение с regexp в строке str. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.

Метод _**regexp.test(str)**_ ищет совпадение и возвращает true/false, в зависимости от того, находит ли он его.
</details>

<details><summary><b>Что такое полифил (polyfill)?</b></summary>
Полифил — это код, реализующий какую-то функциональность, которая не поддерживается в некоторых браузерах. Реализация собственного полифила обеспечивает единообразное поведение функциональности в разных браузерах.

[Полифил] https://habr.com/ru/companies/usetech/articles/687288/
</details>

61. Что такое `switch/case`? Правила использования `switch/case`?
62. Типы функций по способности принимать другие функции?
63. Что такое выражения (expression) и инструкции (statement) в JavaScript?
64. Разница между `.some()` и `.every()`?
65. Как сгенерировать случайное число в JavaScript?
66. Типы операторов в JavaScript?
67. Разница между параметром и аргументом функции?
68. Правила задания имён для переменных и функций в JavaScript?
69. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?
70. Для чего применяется метод `Array.from()`?
71. Назовите способы преобразования массива в объект?
72. Разница между `Object` и `Map`?
73. Что такое каррирование?
75. Для чего используется свойство `.dataset`?
76. Каким образом можно обмениваться кодом между файлами?
<details><summary><b>Как работает «сборщик мусора» в JavaScript?</b></summary>
Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

1. Существует базовое множество достижимых значений, которые не могут быть удалены.

Например:
- Выполняемая в данный момент функция, её локальные переменные и параметры.
- Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
- Глобальные переменные.
- (некоторые другие внутренние значения)

Эти значения мы будем называть корнями.

2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым.

**Сборщик мусора (Garbage Collector)** - это фоновый процесс в движке JavaScript, который идентифицирует недоступные объекты, удаляет их и освобождает основную память.

Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

Движки JavaScript применяют множество оптимизаций, чтобы она работала быстрее и не задерживала выполнение кода.

Вот некоторые из оптимизаций:

- Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
- Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
- Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

Алгоритм помечает (mark) недосягаемые объекты как «мусор», после чего «выметает» (sweep) их; корневые объекты при этом никогда не уничтожаются.

https://learn.javascript.ru/garbage-collection
https://tproger.ru/translations/upravlenie-pamjatju-v-javascript
</details>

<details><summary><b>Что такое утечки памяти? Назовите основные типы утечек памяти в JavaScript?</b></summary>
Утечки памяти происходят, когда браузер по какой-то причине не может освободить память от недостижимых объектов.

Утечка памяти — память, которая больше не требуется приложению, но по какой-то причине не возвращается операционной системе или пулу доступной памяти.

Виды:

**1. Случайные глобальные переменные**

Глобальные переменные всегда доступны из корня скрипта и никогда не будут собраны как мусор с помощью Garbage Collector. Некоторые ошибки вызывают утечку переменных из локальной области в глобальную область в нестрогом режиме:
- присвоение значения необъявленной переменной,
- использование ключевого слова this, которое указывает на глобальный объект.

**Как это предотвратить:** Строгий режим ("use strict") предотвратит случайные утечки, так как код из примера выдаст ошибку.

**2. Замыкания**

Переменные в локальной области любой функции будут очищены после того, как функция вышла из стека вызовов, и если за пределами функции не осталось ссылок, указывающих на них. Замыкание будет поддерживать переменные, на которые имеются ссылки, и живые, хотя функция завершила выполнение, а ее контекст выполнения и переменная среда давно исчезли.

Как это предотвратить: замыкания являются неизбежной и неотъемлемой частью JavaScript, поэтому важно:

- понять, когда замыкание было создано и какие объекты оно удерживает,
- понять ожидаемую продолжительность жизни и использования замыкания (особенно если такая функция используется в качестве обратного вызова - callback-функции).

**3. Таймеры**

Наличие setTimeout или setInterval, ссылающихся на некоторый объект в функции обратного вызова, является наиболее распространенным способом предотвращения сборки мусора. Если мы установим повторяющийся таймер в нашем коде (мы можем заставить setTimeout вести себя как setInterval, т.е. сделать его рекурсивным), тогда ссылка на объект из обратного вызова таймера будет оставаться активной до тех пор, пока обратный вызов будет существовать.

**Как это предотвратить:** особенно если продолжительность жизни функции обратного вызова не определена или неопределенна:

- быть осведомленным об объектах, на которые ссылается обратный вызов таймера,
- используя дескриптор, связанный с таймера, отменить вызов таймера (интервала) методом clearTimer()  (clearInterval()) при необходимости.


**4. Слушатели событий**

Активный слушатель событий, добавленный с помощью метода addEventListener(), предотвратит сбор мусора всех переменных, существующих в его области. После однократного добавления слушатель событий будет действовать до тех пор, пока:
- не будет явно удален с помощью метода removeEventListener()
- связанный со слушателем события элемент DOM будет удален.

**Как это предотвратить:** лучше всегда иметь возможность отменить регистрацию слушателя события, когда он больше не нужен, создав ссылку, указывающую на него, и передав ее в метод removeEventListener().

**5. Кеш**

Если мы продолжим добавлять память в кеш, не избавляясь от неиспользуемых объектов и без какой-либо логики, ограничивающей размер, кеш может расти бесконечно.

**Возможное решение:** чтобы обойти эту проблему, мы можем использовать WeakMap. Это структура данных со слабо удерживаемыми ссылками на ключи, которая принимает в качестве ключей только объекты. Если мы используем объект в качестве ключа, и это единственная ссылка на этот объект - соответствующая запись будет удалена из кэша и собрана сборщиком мусора.

**6. Отдельные элементы DOM**

Если узел DOM имеет прямые ссылки из JavaScript, это предотвратит сбор мусора даже после удаления узла из дерева DOM.

В следующем примере мы создали элемент div и добавили его в document.body. Метод removeChild() не работает должным образом, и снимок кучи покажет отдельный HTMLDivElement, так как есть переменная, все еще указывающая на div.

    function createElement() {
        const div = document.createElement('div');
        div.id = 'detached';
        return div;
    }
    
    // эта константа будет продолжать ссылаться на элемент DOM даже после вызова deleteElement ()
    const detachedDiv = createElement();
    
    document.body.appendChild(detachedDiv);
    
    function deleteElement() {
        document.body.removeChild(document.getElementById('detached'));
    }
    
    deleteElement(); // Снимок покажет отключенный div#detached

**Как это предотвратить?** Одним из возможных решений является перемещение ссылок DOM в локальную область функции. В приведенном ниже примере переменная, указывающая на элемент DOM, удаляется после завершения функции appendElement().

    function createElement() {...} // то же, что и выше
    
    // Ссылки DOM находятся внутри области действия функции
    
    function appendElement() {
        const detachedDiv = createElement();
        document.body.appendChild(detachedDiv);
    }
    
    appendElement();
    
    function deleteElement() {
        document.body.removeChild(document.getElementById('detached'));
    }
    
    deleteElement(); // в снимке нет элемента div#detached

https://html-plus.in.ua/kak-izbezhat-utechek-pamyati-v-javascript/

</details>

80. Как работает контекст выполнения (execution context) в JavaScript?
81. Разница между примитивом и объектом?

---
