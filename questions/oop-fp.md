<h3>
  <img src="../assets/WWW.png" width="16" height="16" />
  <span>OOP & FP:</span>
</h3>

---
<details><summary><b>Основные принципы ООП?</b></summary>

Объектно-ориентированное программирование – это парадигма программирования, в которой основной концепцией является понятие объекта, который отождествляется с предметной областью.

Каждый объект обладает тремя cоставляющими: идентичность (identity), состояние (state) и поведение (behaviour).
- Состояние объекта — это набор всех его полей и их значений.
- Поведение объекта — это набор всех методов класса объекта.
- Идентичность объекта — это то, что отличает один объект класса от другого объекта класса. С точки зрения Java, именно по идентичности определяется метод equals.

Принципы ООП:
- Абстрация
- Инкапсуляция
- Наследование
- Полиморфизм

**_Абстра́кция_** — в объектно-ориентированном программировании это придание объекту характеристик, которые отличают его от всех объектов, четко определяя его концептуальные границы.
Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.

Пример: Скажем, мы создаем картотеку работников компании. Для создания объектов «работник» мы написали класс Employee. Какие характеристики важны для их описания в картотеке компании? ФИО, дата рождения, номер социального страхования, ИНН. Но вряд ли в карточке такого типа нам нужны его рост, цвет глаз и волос. Компании эта информация о сотруднике ни к чему.
Поэтому для класса Employee мы зададим переменные String name, int age, int socialInsuranceNumber и int taxNumber, а от лишней для нас информации вроде цвета глаз откажемся, абстрагируемся.
А вот если мы создаем картотеку фотомоделей для агентства, ситуация резко меняется. Для описания фотомодели нам как раз очень важны рост, цвет глаз и цвет волос, а номер ИНН не нужен.
Поэтому в классе Model мы создаем переменные String height, String hair, String eyes.


**_Инкапсуляция_**: 
Вся информация, которая нужна для работы конкретного объекта, должна храниться внутри этого объекта. Если нужно вносить изменения, методы для этого тоже должны лежать в самом объекте — посторонние объекты и классы этого делать не могут. Для внешних объектов доступны только публичные атрибуты и методы.

Пример: У тебя есть имя и фамилия. Их знают все твои знакомые. Но у них нет доступа к изменению твоего имени и фамилии. Этот процесс, можно сказать, «инкапсулирован» в паспортном столе: поменять имя фамилию можно только там, и сделать это можешь только ты. Остальные «пользователи» имеют доступ к твоему имени и фамилии «только на чтение».

**_Наследование_** — это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и методы.

Например, в каталоге товаров:
1. У класса «Карточка товара» есть атрибуты тип товара, название, цена, производитель, а также методы «Вывести карточку» и «Обновить цену».
2. Подкласс «Смартфон» берёт все атрибуты и методы, записывает в атрибут «тип товара» слово «смартфон плюс добавляет свои атрибуты — «Количество сим-карт» и «Ёмкость аккумулятора».
3. Объект «Смартфон Xiaomi 11» заполняет все атрибуты своими значениями и может использовать методы класса «Карточка товара».

**_Полиморфизм_** - это свойство родственных объектов (т.е. объектов, имеющих одного общего родителя) решать схожие по смыслу проблемы разными способами. В рамках ООП поведенческие свойства объекта определяются набором входящих в него методов. Изменяя алгоритм того или иного метода в потомках объекта, программист может придавать этим потомкам отсутствующие у родителя специфические свойства. Для изменения метода необходимо перекрыть его в потомке, т.е. объявить в потомке одноименный метод и реализовать в нем нужные действия. В результате в объекте-родителе и объекте-потомке будут действовать два одноименных метода, имеющие разную алгоритмическую основу и, следовательно, придающие объектам разные свойства.

Например, метод «Удалить» при вызове в корзине удалит товар только из корзины, а при вызове в карточке товара — удалит саму карточку из каталога.
</details>

<details><summary><b>Что такое SOLID?</b></summary>

SOLID - это принципы разработки программного обеспечения, следуя которым Вы получите хороший код, который в дальнейшем будет хорошо масштабироваться и поддерживаться в рабочем состоянии

1. **Single Responsibility** – принцип единой ответственности.

Для каждого класса/функции должно быть определено единственное назначение.
Функция имеет единственное назначение, если вы не можете осмысленно извлечь из неё другую функцию. Если можете, то исходная функция делала больше, чем одно действие. Относится как к логике компонента, так и к разметке. Выгода: проще читать, тестировать, поддерживать, дорабатывать.

https://www.youtube.com/watch?v=N5QbnmNWctc&list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&ab_channel=%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB%D0%9D%D0%B5%D0%BF%D0%BE%D0%BC%D0%BD%D1%8F%D1%89%D0%B8%D0%B9

2. **Open-closed** – принцип открытости/закрытости.

Программные сущности должны быть открыты для расширения и закрыты для модификации.
- Код должен быть открыт для добавления новых фич;
- Но без необходимости переписывать части кодовой базы (закрыты для модификации);
- В контексте React – используя композицию компонентов;
- Доработка сущностей не должна повлиять на текущую работу системы;
- Внедрение принципа помогает избежать багов в участках, где компонент был использован.

https://www.youtube.com/watch?v=qYBAN9womRc&list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&index=2&ab_channel=%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB%D0%9D%D0%B5%D0%BF%D0%BE%D0%BC%D0%BD%D1%8F%D1%89%D0%B8%D0%B9

3. **Liskov substitution** – принцип подстановки Барбары Лисков.

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.
- Базовая сущность (компонент) имеет конкретный интерфейс;
- Подтипы  (типовые компоненты) наследуют интерфейс и дополняют его по необходимости8;
- Внедрение принципа позволяет сделать использование типовых компонентов предсказуемым и заменить базовые сущности на подтипы.

https://www.youtube.com/watch?v=rQbftW8Ke8Q&list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&index=3&ab_channel=%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB%D0%9D%D0%B5%D0%BF%D0%BE%D0%BC%D0%BD%D1%8F%D1%89%D0%B8%D0%B9

4. **Interface segregation** – принцип разделения интерфейсов.

Много интерфейсов, специально предназначенных для элементов, лучше, чем один интерфейс базового назначения.

- Специфичные интерфейсы компонентов – только то, что необходимо;
- Компонент не должен зависеть от деталей родительского компонента;
- Изменение родительского компонента не должно влиять на дочерние;
- Выгода: низкая связанность компонентов – больше возможностей для повторного использования;
-  React-компоненты не должны зависеть от пропсов, которые они используют.

https://www.youtube.com/watch?v=HiHInuKKzw4&list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&index=4&ab_channel=%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB%D0%9D%D0%B5%D0%BF%D0%BE%D0%BC%D0%BD%D1%8F%D1%89%D0%B8%D0%B9

5. **Dependency inversion** – принцип инверсии зависимостей.

Модули верхних уровней не должны зависеть от модулей нижних. Они должны зависеть от абстракций. Абстракции, в свою очередь, не должны зависеть от деталей. Детали должны зависеть от абстракций.

- Модули верхнего уровня – виджеты;
- Модули нижнего уровня – UI элементы/фича;

Абстракция:

- Отдельный компонент, обеспечивающий связь модулей;
- Класс/функция – подключается к верхнему уровню и через него пробрасывается в нижний;
- Абстракция должна быть независима от конкретных модулей.

https://www.youtube.com/watch?v=COudsR6ybqw&list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&index=5&ab_channel=%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB%D0%9D%D0%B5%D0%BF%D0%BE%D0%BC%D0%BD%D1%8F%D1%89%D0%B8%D0%B9

_Кроме этого, есть следующие принципы:_

**YAGNI** (You Aren't Gonna Need It):
1) Реализуйте только то, что нужно здесь и сейчас;
2) Подчищайте ненужный код;
3) Программист не должен добавлять новый функционал, о котором его не просят.

**KISS** (Keep It Simple):
1) Методы небольшие;
2) Каждый метод решает одну проблему;
3) Не усложняйте без надобности;
4) Писать код нужно надежно и "дубово".

**DRY** (Do It Yourself):
1) Избегайте копирования кода;
2) Выносите общую логику;
3) Константы;
4) Проверяйте проект перед добавлением новой фичи.

https://youtube.com/playlist?list=PLz_dGYmQRrr8rWKkoB3BtxF7JpCzUKny_&si=b8sBV10xKQLNasBo
https://youtube.com/playlist?list=PLiZoB8JBsdznXsIsi14OSRfxBkIlCl8FX&si=R0xrQIKOonSrq78z
</details>

<details><summary><b>Разница между классовым и прототипным наследованием?</b></summary>

При следовании парадигме **классического наследования** нам необходимо создавать иерархию классов от общего к частному создавая тем самым при каждом наследовании дополнительный уровень абстракции.
Экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор new.
Задача программиста при использовании парадигмы классического наследования создать иерархию сущностей от максимальной общей к максимально конкретной.

При следовании парадигме **прототипного наследования** мы не обязаны создавать иерархию от общего к частному, мы можем это делать а можем и не делать. Это оставляет нам свободу выбора, что и является главным отличием этих двух парадигм.
Экземпляры наследуются напрямую от других объектов, реализуются через фабрики или Object.create() и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое.
При использовании парадигмы прототипного наследования программист имеет дело только с объектами и при этом у него есть возможность создавать сущности в одном уровне абстракции.

https://webdevblog.ru/chem-prototipnoe-nasledovanie-otlichaetsya-ot-klassicheskogo/

</details>

<details><summary><b>Однонаправленный поток данных и двусторонняя связь данных? В чем между ними разница?</b></summary>
Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот.

Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или "store" в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.

Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.
</details>

<details><summary><b>Что такое функциональное программирование и его принципы (особенности)?</b></summary>
Функциональные языки программирования — это языки, в которых процессы представлены как функции в математическом понимании этого слова. То есть функция в них определяется не как подпрограмма, а как соответствие между множествами.

Такой подход к программированию называют функциональным. Название не значит, что код основан на функциях: это справедливо почти для любого языка. Функциональность определяется именно подходом: весь код описывается как правила работы с информацией, и они могут исполняться в любом порядке.

Функциональный подход — противоположность императивному, в котором программист задает программе четкий порядок действий по шагам. Тут все сложнее: программа сама решает, как и в каком порядке исполнять действия, а программист описывает правила взаимодействия и связи между компонентами.

Особенности:
- **Отсутствие жесткой последовательности:** разработчик задает правила, а компилятор кода сам решает, в какой последовательности их выполнять;
- **"Чистые функции":** функции, которые при одинаковых входных данных всегда вернет одинаковый результат и при её выполнении не возникают побочные эффекты (действия, которые влияют на что-то за её пределами (вывод в консоль));
- **Неизменные переменные:** если с какой-то переменной нужно провести вычисления, она не изменяется: создается новая переменная, и результат вычислений записывается в нее. А исходная остается прежней — ее значение не меняется;
- **"Первоклассные" функции высшего порядка.**

Функции первого класса –  это такая, которую можно представить как переменную. То есть, ее можно передавать как аргумент другим функциям, возвращать как результат работы других функций, сохранять в переменную или структуру данных.

Функция высшего порядка — такая, которая принимает в качестве аргументов функции или возвращает их в качестве результата.
- **Относительная прозрачность:** означает, что выражение, которое возвращает функция, можно заменить значением — и от этого ничего не изменится. То есть, если функция, например, складывает два числа 3 и 5, то она вернет сумму 3 + 5. Теоретически вместо этой функции в выражение можно подставить число 8, и от этого программа не изменится — она будет работать так же.
- **Рекурсия вместо циклов:** в классическом функциональном программировании циклы реализованы как рекурсия. Стоит понимать разницу:

цикл — несколько выполнений одной и той же части кода подряд;

рекурсия — явление, когда функция вызывает сама себя, но с другими аргументами.
- **Лямбда-исчисление:**

В λ-исчислении есть две основных операции — аппликация и абстракция. Первое — это, по сути, вызов функции к заданному значению. Второе — построение функции по имеющимся выражениям;

Все функции могут быть анонимными и складываться только из списка аргументов. Анонимные функции — это такие, у которых нет уникального имени, а объявляются они в месте выполнения;

При вызове функции с несколькими аргументами происходит ее каррирование — преобразование в несколько функций, в каждой из которых один аргумент. То есть, функция вида f(a, b, c) превратится в набор функций f(a)(b)(c). Результатом f(a) будет функция, которая тут же применится к аргументу b. И так далее. Это рекурсия — та, о которой мы говорили выше.

https://blog.skillfactory.ru/glossary/funkczionalnye-yazyki-programmirovaniya/

</details>

<details><summary><b>Что такое MVC?</b></summary>
MVC расшифровывается как «модель-представление-контроллер» (от англ. model-view-controller). Это способ организации кода, который предполагает выделение блоков, отвечающих за решение разных задач.

Компоненты MVC:

Модель (Model). Это основная логика приложения. Отвечает за данные, методы работы с ними и структуру программы. Модель реагирует на команды из контроллера и выдает информацию и/или изменяет свое состояние. Она передает данные в представление.

Представление (View). Задача компонента — визуализация информации, которую он получает от модели. View отображает данные на уровне пользовательского интерфейса. Например, в виде таблицы или списка. Представление определяет внешний вид приложения и способы взаимодействия с ним.

Контроллер (Controller). Он обеспечивает взаимодействие с системой: обрабатывает действия пользователя, проверяет полученную информацию и передает ее модели. Контроллер определяет, как приложение будет реагировать на действия пользователя. Также контроллер может отвечать за фильтрацию данных и авторизацию.

Компоненты модели различаются степенью зависимости друг от друга и ограничениями:
- модель не зависит от представления и контроллера, но и не может использовать классы из их разделов;
- представление может обращаться к модели за данными и событиями, но не может ее менять;
- контроллер не может отображать данные, но способен менять модель в зависимости от действий пользователя.

**Доступ к данным (Model) есть у View и у контроллера. То есть View может перерисовываться самостоятельно лишь на основании изменения данных в Model или взаимодействия пользователя с View (нажатие на экран), или сама изменить данные в Model; и только сообщить контроллеру об этом. Controller может изменять состояние View на основании своих источников данных (напр. внешние запросы, нажатие на кнопку) и тоже может менять Model.**

https://blog.skillfactory.ru/glossary/mvc/
</details>

<details><summary><b>Что такое MVVM?</b></summary>

MVVM (Model-View-ViewModel) — шаблон проектирования, позволяющий разделить архитектуру на три функциональные части:

Модель описывает используемые данные и содержит основную логику программы.

Представление определяет визуальный интерфейс, через который пользователь взаимодействует с приложением.

Модель представления служит прослойкой между моделью и представлением посредством механизма привязки данных. Так, если в модели изменяются значения свойств, при реализации моделью интерфейса автоматически изменяются отображаемые данные в представлении, хотя напрямую модель и представление не связаны.

_Пример:_

Допустим, пользователь вводит текст в поле ввода сообщения в приложении-мессенджере и нажимает "Отправить". View изменяет ViewModel. ViewModel выставляет атрибут isMessageRead в значение false и обновляет Model. В нашем примере Model – это абстракция для слоя взаимодействия с бэкендом. Обновление модели значит отправка запроса с введенным сообщением.

Далее собеседник читает сообщение. Model обновляется по сети (например приходит сигнал по сокет-соединению). ViewModel получает оповещение об обновлении Model и обновляет себя, меняя значение атрибута isMessageRead на true. View наблюдает обновление ViewModel и отрисовывает изменение.

Главное отличие от MVC заключается в том, что в MVVM View более пассивно, оно не содержит бизнес-логики и большая часть взаимодействия с данными и действиями пользователя обрабатывается в ViewModel, что делает код более легко тестируемым и позволяет лучше разделять ответственности между компонентами.

MVVM удобно использовать вместо классического MVC и ему подобных в тех случаях, когда в платформе, на которой ведётся разработка, есть «связывание данных». В шаблонах проектирования MVC/MVP изменения в пользовательском интерфейсе не влияют непосредственно на Mодель, а предварительно идут через Контроллер (англ. Controller) или Presenter.

**ViewModel также является посредником между View и моделью. Но ViewModel не может напрямую воздействовать на View, а лишь является источником данных и имеет возможность через функции вызова передавать актуальные данные. То, что отображать, определяется на уровне View.**
</details>

<details><summary><b>Что такое MVP?</b></summary>
MVP — это паттерн программирования графических интерфейсов. В нём приложение делится на три компонента:

- Model (Модель) работает с данными, проводит вычисления и руководит всеми бизнес-процессами.
- View (Вид или представление) показывает пользователю интерфейс и данные из модели.
- Presenter (Представитель) служит прослойкой между моделью и видом.

Как работает MVP

1. Вид строит интерфейс и добавляет в него данные из модели.
2. Пользователь видит информацию и взаимодействует с интерфейсом.
3. Вид перехватывает события и передаёт (делегирует) их представителю.
4. Представитель обрабатывает данные (не всегда) и передаёт их модели.
5. Модель выполняет какие-то операции и обновляется (меняет те или иные свойства).
6. Представитель получает обновлённую модель и передаёт её виду.
7. Вид строит интерфейс с новыми данными.

**Presenter является посредником между View и моделью. View и модель меняются данными через установленное API. Отображение во View зависит только от данных, которые установил Presenter.**
</details>

<details><summary><b>Недостатки паттерна MVW?</b></summary>
MVW расшифровывается как Model View Whatever (Модель Представление Что угодно). MVW легко управлять в простом приложении, содержащем несколько моделей и контроллеров. 

При росте приложения можно столкнуться со следующими проблемами:

1. Модели и контроллеры взаимодействуют: эти модули меняют состояния друг друга, и чем больше модулей, тем легче утратить контроль над тем, как изменено состояния того или иного модуля;
2. Асинхронные сетевые запросы добавляют элемент неожиданности в то, когда модель будет изменена или модифицирована. Достаточно представить кейс, что пользователь изменил UI до того, как пришел ответ на асинхронный запрос;
3. Изменение состояния модели добавляет еще один уровень сложности – мутацию. Требуется определить, каким образом изменяется состояние или модель и какие инструменты необходимы для распознования мутации.
4. Код совместно используемого приложения (Google docs), где множество данных меняются в режиме реального времени, будет просто огромным;
5. Нет возможности отменять действия, возвращаться назад во времени, без добавления большого количества дополнительного кода. 
</details>

<details><summary><b>Разница между функцией и методом?</b></summary>
Функция - подпрограмма, выполняющая какие-либо операции и возвращающая значение.

Процедура - подпрограмма, которая только выполняет операции, без возврата значения.

Метод - это функция или процедура, которая принадлежит классу или экземпляру класса.
</details>

<details><summary><b>Что такое каррирование (Currying)?</b></summary>
Каррирование или карринг (currying) в функциональном программирование — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.

_Пример:_

    function curry(f) { // curry(f) выполняет каррирование
        return function(a) {
            return function(b) {
                return f(a, b);
            };
        };
    }

    // использование
    function sum(a, b) {
        return a + b;
    }

    let curriedSum = curry(sum);

    alert( curriedSum(1)(2) ); // 3

_Продвинутая реализация:_
    
    function curry(func) {
        return function curried(...args) {
            if (args.length >= func.length) {
                return func.apply(this, args);
            } else {
                return function(...args2) {
                    return curried.apply(this, args.concat(args2));
                }
            }
        };
    }

    // func -- функция, которую мы трансформируем
    function curried(...args) {
        if (args.length >= func.length) { // (1)
            return func.apply(this, args);
        } else {
            return function pass(...args2) { // (2)
                return curried.apply(this, args.concat(args2));
            }
        }
    };
    
    function sum(a, b, c) {
        return a + b + c;
    }
    
    let curriedSum = curry(sum);
    
    alert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально
    alert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента
    alert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов

Когда мы запускаем её, есть две ветви выполнения if:

- Вызвать сейчас: если количество переданных аргументов args совпадает с количеством аргументов при объявлении функции (func.length) или больше, тогда вызов просто переходит к ней.
- Частичное применение: в противном случае func не вызывается сразу. Вместо этого, возвращается другая обёртка pass, которая снова применит curried, передав предыдущие аргументы вместе с новыми. Затем при новом вызове мы опять получим либо новое частичное применение (если аргументов недостаточно) либо, наконец, результат.

Применяется, когда у нас есть функция, у которой первый аргумент неизменен, и эта функция вызывается несколько раз. И чтобы каждый раз не вызывать её с повторяющемся аргументом, можно воспользоваться каррированием.
</details>

<details><summary><b>Разница между ООП и ФП в JavaScript?</b></summary>
ООП объединяет данные и связанное с ними поведение в объект. Это помогает программистам легче понять, как работает программа, хотя код намного длиннее, чем в ФП. 

ООП отлично работает, когда поведение программы четко определено, но типы данных меняются;

ФП четко различает данные и поведение, не смешивая их в коде. В результате, в ФП коде можно легко и просто находить ошибки, но его труднее прочесть.

ФП лучше подходит, когда все объекты понятны, но поведение может измениться.
</details>

<details><summary><b>Плюсы и минусы ФП и ООП?</b></summary>

**_ООП_**

_Преимущества:_
- **Модульность**: объектно-ориентированный подход позволяет сделать код более структурированным, в нем легко разобраться стороннему человеку. Благодаря инкапсуляции объектов уменьшается количество ошибок и ускоряется разработка с участием большого количества программистов, потому что каждый может работать независимо друг от друга.
- **Гибкость**: ООП-код легко развивать, дополнять и изменять. Это обеспечивает независимая модульная структура. Взаимодействие с объектами, а не логикой упрощает понимание кода. Для модификации не нужно погружаться в то, как построено ПО. Благодаря полиморфизму можно быстро адаптировать код под требования задачи, не описывая новые объекты и функции.
- **Экономия времени**: благодаря абстракции, полиморфизму и наследованию можно не писать один и тот же код много раз. Это ускоряет разработку нового ПО. Интерфейсы и классы в ООП могут легко преобразовываться в подобие библиотек, которые можно использовать заново в новых проектах. Также ООП экономит время при поддержке и доработке приложения.
- **Безопасность**: программу сложно сломать, так как инкапсулированный код недоступен извне.

_Недостатки:_

- **Сложный старт**: чтобы пользоваться ООП, нужно сначала изучить теорию и освоить процедурный подход, поэтому порог входа высокий.
- **Снижение производительности**: объектно-ориентированный подход немного снижает производительность кода в целом. Программы работают несколько медленнее из-за особенностей доступа к данным и большого количества сущностей.
- **Большой размер программы**: код, написанный с использованием ООП, обычно длиннее и занимает больше места на диске, чем «процедурный». Это происходит, потому что в такой программе хранится больше конструкций, чем в обычном процедурном скрипте.

**_ФП_**

_Преимущества:_
- **Чистота кода**: код, написанный на функциональном языке, выглядит чистым и понятным. Сюда же можно отнести локальную читаемость — можно разобраться, как работает та или иная функция, без строгой привязки к остальному коду. Код более чистый еще и за счет отсутствия четкой последовательности: чтобы понять происходящее в нем, не обязательно знать порядок выполнения разных действий.
- **Надежность**: благодаря тому, что функции чистые и не изменяют окружение вокруг себя, функциональный код более надежен. Если в одной конкретной функции что-то сломается, это не повлечет за собой проблемы с другими компонентами. Не нужно отслеживать побочные эффекты — согласно определению чистой функции их быть просто не должно. Правда, на практике это не всегда возможно, но эту деталь мы подробнее обсудим ниже.
- **Оптимизация**: когда компилятор обрабатывает функциональную программу, он сам решает, в каком порядке вызывать функции. За счет этого программы легче оптимизировать: такой подход открывает широкие возможности для автоматической оптимизации на уровне компилятора. Оптимизация означает, что код будет быстрее или производительнее.
- **Удобное тестирование**: благодаря все тем же чистым функциям этот стиль программирования удобнее отлаживать и тестировать. Особенно это заметно при модульном тестировании — таком, где каждый компонент проверяется по отдельности. Ведь если мы проверяем функцию, которая не изменяет ничего снаружи — значит, нам не нужно дополнительно думать о тестировании возможных побочных эффектов.
- **Распараллеливание вычислений**: за счет отсутствия жесткой последовательности функциональное программирование отлично подходит для параллельных вычислений — одновременного выполнения нескольких действий. С императивным подходом их сложнее организовать, кроме того, нужно учитывать побочные эффекты. А функциональное программирование гарантирует, что вызов одной функции не повлияет на вызов другой — поэтому снижается риск ошибок и конфликтов при параллельных вычислениях.
- **Гибкая работа с функциями**: благодаря гибкой и сложной работе с функциями некоторые действия можно выполнять быстрее и удобнее, чем с императивным подходом. Это мощный инструмент, особенно для решения специфических задач: математических, научных, связанных с точными вычислениями или подобными сферами. Популярность подхода при решении таких задач видно и на практике: языки для математических, научных, экономических или статистических расчетов — по большей части функциональные.

_Недостатки:_
- **Использование большого объема памяти**: этот минус вытекает из тех же особенностей, что и преимущества. Многие действия построены на рекурсии, а при изменении любого значения создается новая переменная — поэтому программа начинает требовать больше памяти, чем императивная с классическими циклами и изменяемыми значениями. Это значит, что для эффективной работы в языке должен быть мощный сборщик мусора или удобные инструменты для ручной работы с памятью. За ней нужно следить, иначе есть риск серьезного снижения производительности.
- **Непредсказуемый порядок действий**: эта особенность функционального программирования — плюс и минус одновременно. О плюсах мы уже говорили выше. Минус в том, что для некоторых важных задач порядок действий важен по определению. Например, ввод и вывод. Если данные будут вводиться или выводиться хаотично, в непредсказуемом порядке, это ухудшит работу программы. Поэтому часто функциональное программирование комбинируют с императивным — для большей гибкости и производительности кода в целом.
- **Неуниверсальность чистых функций**: одними чистыми функциями не получится решить многие задачи. Некоторые важные действия по определению сложно или невозможно реализовать через чистые функции. Поэтому программистам приходится прибегать к дополнительным ухищрениям и усложнять код, чтобы избежать этого минуса. Также некоторые функции на практике оказываются не совсем чистыми — тут опять же приходится обходить ограничения и придумывать новые способы.

https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/
http://www.chernyshov.com/PL/Plus_OOP.htm
https://blog.skillfactory.ru/glossary/funkczionalnye-yazyki-programmirovaniya/
</details>

<details><summary><b>Разница между монолитной и микросервисной архитектурами?</b></summary>

**Монолитное приложение** относится к программной архитектуре, в которой все компоненты приложения, включая пользовательский интерфейс, серверный код и базы данных, объединены в единый неделимый блок, называемый монолитом. Вся функциональность управляется в рамках монолита, и все выполняется в рамках одного процесса.


**Приложения микрослужб** — это архитектурный подход, который разбивает приложение на набор небольших, независимо развертываемых служб, каждая из которых ориентирована на определенные бизнес-возможности. Микросервисы взаимодействуют друг с другом с помощью облегченных протоколов, таких как RESTful API или очереди обмена сообщениями.

**Различия между монолитной и микросервисной архитектурой**

- **Структура приложения**: в монолитной архитектуре все компоненты объединены в неделимую единицу, а в архитектуре микросервисов компоненты организованы в более мелкие независимые службы, ориентированные на определенные бизнес-возможности.
- **Разработка и развертывание**: монолитные приложения проще разрабатывать и развертывать благодаря уникальной природе архитектуры. Тем не менее приложения микросервисов требуют больше усилий при развертывании, оркестровке и мониторинге отдельных компонентов. Несмотря на дополнительную сложность, архитектуры микросервисов обеспечивают большую гибкость и позволяют независимо развертывать компоненты, ускоряя выпуск новых функций и снижая риск сбоя.
- **Масштабируемость**: монолитные приложения часто сталкиваются с проблемами масштабирования, поскольку добавление ресурсов требует масштабирования всего монолита, что может быть ресурсоемким и неэффективным. Напротив, микросервисные архитектуры обеспечивают независимое масштабирование сервисов в зависимости от их конкретных требований, что приводит к эффективному распределению ресурсов и повышению производительности.
- **Ремонтопригодность**: монолитные приложения могут быть сложными в обслуживании из-за взаимозависимости компонентов. Изменение одного компонента может иметь каскадные последствия для всего приложения, увеличивая риск сбоя и затрудняя быстрое выполнение исправлений и обновлений. Архитектуры микрослужб обеспечивают лучшую ремонтопригодность, позволяя осуществлять независимую разработку и обновление компонентов с минимальным влиянием на другие службы.
- **Стек технологий**: монолитные приложения обычно имеют единый унифицированный стек технологий, что может ограничивать гибкость при выборе лучших инструментов для конкретных задач. С другой стороны, микросервисные архитектуры позволяют использовать различные технологические стеки в каждом сервисе, что позволяет командам выбирать наиболее подходящие инструменты для своих конкретных потребностей.

Выбор между монолитной архитектурой и архитектурой микросервисов зависит от таких факторов, как сложность проекта, требования к масштабируемости, опыт команды и бюджет. Монолитные архитектуры хорошо подходят для простых приложений с низкими требованиями к масштабируемости, в то время как микросервисные архитектуры больше подходят для сложных крупномасштабных приложений, требующих гибкости и масштабируемости.

</details>

<details><summary><b>Плюсы и минусы монолитной и микросервисной архитектур?</b></summary>

**_Монолитная архитектура_**

_Преимущества:_
- **Упрощенная разработка**: в монолитной архитектуре вся кодовая база приложения управляется в одном репозитории, что обеспечивает простой процесс разработки. Этот упрощенный подход помогает разработчикам понять кодовую базу, устранить проблемы, связанные с взаимодействием между службами, и более эффективно управлять кодом.
- **Более простое развертывание**: для монолитных приложений требуется меньше шагов по развертыванию, чем для микросервисов, поскольку все решение упаковано в единый модуль. Таким образом, процессы развертывания, как правило, более простые и быстрые для монолитных приложений.
- **Унифицированная организация кода**. Все компоненты монолитной архитектуры тесно интегрированы, что упрощает совместное использование кода и библиотек в приложении. Эта унифицированная структура приводит к лучшей организации и согласованности всей кодовой базы.
- **Лучшая производительность**: монолитные приложения могут обеспечить лучшую производительность благодаря отсутствию накладных расходов на обмен данными между службами. Взаимодействие нескольких служб по сети не приводит к дополнительной задержке, что приводит к повышению производительности.

_Недостатки:_
- **Ограниченная масштабируемость.** Масштабирование монолитного приложения может стать сложной задачей, поскольку все приложение должно масштабироваться вместе, а не только необходимые части. Это отсутствие гибкости часто увеличивает затраты и снижает эффективность при работе с большими нагрузками.
- **Сложность обслуживания**: поддержка монолитной кодовой базы становится все более сложной задачей по мере роста сложности и размера приложения. Эта трудность связана с тесной связью компонентов, из-за чего разработчикам сложнее модифицировать или отлаживать приложение, не затрагивая другие части.
- **Негибкий технологический стек**: монолитные архитектуры построены с использованием единого технологического стека, что затрудняет внедрение новых технологий или переход на другие инструменты. Эта жесткость может препятствовать инновациям и замедлять развитие.
- **Риск единой точки отказа**: в монолитной архитектуре, если один компонент выходит из строя, все приложение может стать нефункциональным. Этот риск создает серьезные проблемы в обеспечении высокой доступности и отказоустойчивости для критически важных приложений.

**_Микросервисная архитектура_**

_Преимущества:_
- **Улучшенная масштабируемость**. Архитектура микрослужб обеспечивает лучшую масштабируемость, поскольку отдельные службы можно масштабировать независимо друг от друга. Такая гибкость позволяет эффективно управлять ресурсами, позволяя приложению эффективно справляться с возросшей нагрузкой.
- **Более простое обслуживание**: поскольку микросервисы сосредоточены на определенных бизнес-возможностях, разработчики могут поддерживать и обновлять компоненты, не затрагивая всю систему. Эта модульность приводит к более управляемым кодовым базам и более быстрым циклам итераций.
- **Гибкость в стеке технологий**: различные микросервисы могут разрабатываться с использованием разных стеков технологий, что позволяет каждому сервису использовать лучшие инструменты и технологии. Такая гибкость способствует инновациям и повышает качество вашего приложения.
- **Независимое развертывание**. Микросервисы можно развертывать независимо, что способствует непрерывной доставке и снижает риск развертывания новых функций. Эта возможность позволяет выпускать более мелкие и частые выпуски и ускорять вывод новых функций на рынок.
- **Уменьшение влияния сбоев**: в архитектуре микросервисов влияние на систему ограничено в случае сбоя одной службы. Такая степень детализации обеспечивает лучшую изоляцию сбоев и гарантирует, что другие части системы могут продолжать функционировать даже в условиях локальных сбоев.

**_Недостатки_:**
- **Повышенная сложность**. Архитектура микросервисов создает дополнительную сложность из-за распределенного характера системы. Разработчикам необходимо управлять взаимодействием между службами, управлением распределенными данными и дополнительными операционными издержками.
- **Дополнительные затраты на разработку и эксплуатацию**. В отличие от монолитных приложений разработка микросервисов и управление ими требует больше ресурсов, времени и усилий. В некоторых случаях эти накладные расходы могут увеличить затраты и замедлить разработку.
- **Потенциальные потери производительности**. Взаимодействие между службами в архитектуре микрослужб может привести к задержке и увеличению времени отклика. Это снижение производительности может потребовать оптимизации и тонкой настройки для обеспечения бесперебойной работы.
- **Проблемы в распределенном управлении данными**. Микросервисы часто требуют распределенного управления данными, что создает сложности, такие как возможная согласованность и синхронизация данных. Эти проблемы могут увеличить усилия по развитию и привести к потенциальным ловушкам, если их не решить должным образом.

https://appmaster.io/ru/blog/monolitnaia-i-mikroservisnaia-arkhitektura
</details>

16. Какие принципы можно использовать вместе с наследованием?
<details><summary><b>Какие ещё принципы кроме SOLID вы знаете?</b></summary>

**YAGNI** (You Ain't Gonna Need It):
1) Реализуйте только то, что нужно здесь и сейчас;
2) Подчищайте ненужный код;
3) Программист не должен добавлять новый функционал, о котором его не просят.

**KISS** (Keep It Simple):
1) Методы небольшие;
2) Каждый метод решает одну проблему;
3) Не усложняйте без надобности;
4) Писать код нужно надежно и "дубово".

**DRY** (Do It Yourself):
1) Избегайте копирования кода;
2) Выносите общую логику;
3) Константы;
4) Проверяйте проект перед добавлением новой фичи.

**BDUF** (Big Desigh Up Front):
1) Прежде чем переходить к реализации, убедитесь, что все продумано;
2) Разработчик должен сначала завершить проектирование. После этого проект можно реализовать;
3) Разделите требования на несколько этапов, определите приоритеты, начинайте с этапа с наивысшим приоритетом;
4) Обсудите архитектуру проекта с командой и другими людьми, которые участвуют в проекте до старта.

**SoC** (Separation of Concerns (принцип разделения ответственности))

SoC помогает объединять функции или модули в отдельные сервисы. Суть в том, что при проектировании многофункциональной системы — а так обычно и бывает — можно группировать функции в модули в зависимости от задач, которые каждая из них выполняет.

SoC также может применяться при создании API, архитектур библиотек и тому подобного. Его суть в том, чтобы группировать функции по своему усмотрению и с пользой для тех, кто будет их применять.
</details>

<details><summary><b>Что такое дескрипторы свойств объектов?</b></summary>

Объекты, как мы знаем, содержат свойства. У каждого из свойств объекта, кроме значения, есть ещё три флага конфигурации, которые могут принимать значения true или false. Эти флаги называются дескрипторами:

- writable — доступно ли свойство для записи;
- enumerable — является ли свойство видимым при перечислениях (например, в цикле for..in);
- configurable — доступно ли свойство для переконфигурирования.

Когда мы создаём свойство объекта «обычным способом», эти три флага устанавливаются в значение true.

Для изменения значений дескрипторов применяется статический метод Object.defineProperty(), а для чтения значений — Object.getOwnPropertyDescriptors().

Другими словами, дескрипторы — это пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи).

    const laptop = {}
    
    Object.defineProperty(laptop, 'os', {
        value: 'MacOS',
        writable: false,
        enumerable: true,
        configurable: true
    })

Дескрипторы, которые мы можем передать в Object.defineProperty() могут быть двух типов — **дескриптор данных** и **дескриптор доступа**. Каждый тип дескриптора имеет свой набор свойств.

В обоих типах можно использовать общие свойства configurable и enumerable. Дескриптор, передаваемый в Object.defineProperty() может быть только одним типом дескриптора. Он не может быть одновременно обоими!

**Дескриптор данных** — это дескриптор, который определяет значение свойства и возможность изменить это значение.
- value — значение свойства, по умолчанию undefined.
- writable — можно ли изменить значение с помощью оператора присваивания.

**Дескриптор доступа** — это дескриптор, который определяет работу свойства через функции чтения и записи свойства (геттера и сеттера).
- get — функция, используемая для получения значения свойства, возвращает значение или undefined.
- set — функция, используемая для установки значения свойства. Принимает единственным аргументом новое значение, присваиваемое свойству.

https://doka.guide/js/descriptors/#:~:text=getOwnPropertyDescriptors()%20.,%D0%BF%D0%BE%D0%B4%20%D0%BA%D0%B0%D0%BF%D0%BE%D1%82%D0%BE%D0%BC%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%20%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%20%D0%B4%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80%D0%BE%D0%B2.
</details>

<details><summary><b>В чем заключаются особенности геттеров и сеттеров?</b></summary>

В JS есть особый тип свойств — это свойства-аксессоры. Их особенность в том, что при обращении к этим свойствам вызываются функции, которые выполняют необходимую работу. Все взаимодействия со свойствами сводятся к двум операциям: получение значения из свойства и присваивание нового значения свойству. То есть, чтобы работать со свойством объекта, достаточно описать две операции: операцию получения значения из свойства и операцию сохранения значения в свойство. Это и есть геттеры и сеттеры. **_Геттер_** — занимается извлечением значения из свойства, а **_сеттер_** — сохранением значения. Для этого в JS есть специальный механизм, в котором ставится get перед геттером и set перед сеттером.

    const user = {
        firstName: 'Ivan',
        lastName: 'Ivanov',
        get fullName() {
            return `${this.firstName} ${this.lastName}`;
        },
        set fullName(fullName) {
            const [first, second] = fullName.split(' ');
            this.firstName = first;
            this.lastName = second;
        },
    };
    
    user.fullName = 'Petr Petrov';
    console.log(user); // => {firstName: 'Petr', lastName: 'Petrov'}
</details>

<details><summary><b>Что такое статический метод класса (`static`)? Как осуществляется его вызов?</b></summary>
Мы можем присвоить метод самому классу. Такие методы называются _статическими_.

В объявление класса они добавляются с помощью ключевого слова _static_, например:

    class User {
        static staticMethod() {
            alert(this === User);
        }
    }
    
    User.staticMethod(); // true

Обычно статические методы используются для реализации функций, которые будут принадлежать классу в целом, но не какому-либо его конкретному объекту.

Статические свойства и методы наследуются.

</details>

<details><summary><b>Разница между композицией и наследованием?</b></summary>

**Наследование** — это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и методы.

В отличие от наследования, в **композиции** используется отношение имеет-а. Мы собираем разные кусочки функциональности вместе.

Композиция удобна, когда мы описываем отношения "имеет", в то время как наследование полезно при описании отношений "является".

И, конечно же, мы можем объединить наследование и композицию вместе, если у нас есть отношение «есть-а», но мы хотим добавить разные значения или методы, мы можем иметь некоторый базовый класс, который дает все общие функции для наших экземпляров, и мы также можем использовать композицию для добавления других, конкретных функций.
</details>

<details><summary><b>Что такое композиция в контексте JavaScript?</b></summary>

Композиция — это способ построения больших модулей из более мелких.
При композиции входные данные одной функции приходят из выходных данных предыдущей.
Таким образом, проще отлаживать, тестировать, поддерживать, повторно использовать и интереснее разрабатывать функции.

В JavaScript композиция, где f и g - это функции, будет выглядеть так:
    
    const compose = (f, g) => (x) => f(g(x))
Функция compose является композицией функций f и g. Выходные данные функции g будут переданы на вход функции f. По другому эта запись выглядела бы следующим образом:

    const compose = (f, g) => {
        return (x) => {
            const gResult = g(x)
            const fResult = f(gResult)
            return fResult
        }
    }
</details>

<details><summary><b>Что такое паттерн, или шаблон проектирования?</b></summary>
Паттерны проектирования — это способы построения программ, которые считаются хорошим тоном для разработчиков. Их еще называют шаблонами или образцами: чаще всего паттерн — это типовое решение для часто встречающейся задачи на построение.

**Паттерны проектирования** предоставляют решения для доработки и построения подсистем на уровне кода. Обычно на их выбор влияет язык программирования, а разработчик сам принимает решение, какой паттерн использовать.

**Архитектурные паттерны** (архитектурные шаблоны, architectural patterns) рассматриваются на более высоком уровне. Они определяет архитектуру приложения, задают его логику (на какие компоненты/модули будет делиться приложение и каким образом они взаимодействуют) и помогают разработчику понять, как устроен продукт внутри. Выбор паттернов происходит на этапе создания продукта.

**Алгоритм** — это чёткий набор действий, **паттерн** — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.
</details>

<details><summary><b>Типы паттернов GoF?</b></summary>

GoF (Gang of Four) – четыре автора 23х основных паттернов (Erich Gamma, Richard Helm, Ralph Johnson и John Vlissides).

В зависимости от того, какие задачи решают паттерны, они делятся на три вида — порождающие, структурные и поведенческие.

**Порождающие** предназначены для создания экземпляра объекта или группы связанных объектов. К ним относятся:

**_Factory(Фабрика)_** Сам по себе не является паттерном. Подход, при котором логика создания объектов выносится в отдельный класс.

**_Фабричный метод(Factory Method)_** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

**_Абстрактная фабрика (Abstract factory)_** — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

**_Прототип (Prototype)_** Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип. Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.

**_Строитель(Builder)_** — порождающий шаблон проектирования предоставляет способ создания составного объекта. Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

**_Одиночка (Singleton)_** — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр класса с глобальной точкой доступа.

**Структурные** в основном связаны с композицией объектов, с тем, как сущности могут использовать друг друга. Эти шаблоны проектирования помогают специалистам по программированию организовать множество классов и объектов в своих программах. Структурные модели проектирования также помогают обеспечить эффективность и гибкость программы. К ним относятся:

**_Адаптер (Adapter)_** — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

**_Мост (Bridge)_** — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо». Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

**_Компоновщик (Composite pattern)_** — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково

**_Декоратор (Decorator)_** — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

**_Фасад (Facade)_** — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

**_Приспособленец (Flyweight, "легковесный (элемент)")_** — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.

**_Заместитель (Proxy)_** — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).

**Поведенческие** связаны с распределением обязанностей между объектами. Их отличие от структурных шаблонов заключается в том, что они описывают не только структуру, но и способы общения между ними. Эти шаблоны определяют, как ведут себя объекты программы. К ним относятся:

**_Цепочка обязанностей (Chain of responsibility)_** — поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности.

**_Команда (Command)_** — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.

**_Интерпретатор (Interpreter)_** — поведенческий шаблон проектирования, решающий часто встречающуюся, но подверженную изменениям, задачу. Также известен как Little (Small) Language

**_Итератор (iterator)_** — интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним. В различных системах итераторы могут иметь разные общепринятые названия. В терминах систем управления базами данных итераторы называются курсорами.

**_Посредник (Mediator)_** — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга

**_Хранитель (Memento)_** — поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.

**_Наблюдатель (Observer)_** — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.

**_Состояние (State)_** — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

**_Стратегия (Strategy)_** — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

**_Шаблонный метод (Template method)_** — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

**_Посетитель (visitor)_** — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.

https://habr.com/ru/articles/210288/
</details>

<details><summary><b>Что такое GRASP паттерны?</b></summary>

GRASP (General Responsibility Assignment Software Patterns) — шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам.

Известно девять GRAPS шаблонов, изначально описанных в книге Крейга Лармана «Применение UML и шаблонов проектирования». В отличие от привычных читателю паттернов из Банды Четырех, GRAPS паттерны не имеют выраженной структуры, четкой области применения и конкретной решаемой проблемы, а лишь представляют собой обобщенные подходы/рекомендации/принципы, используемые при проектировании дизайна системы.

Основные шаблоны:

- **_Information Expert (Информационный эксперт)_** – Шаблон определяет базовый принцип распределения ответственности: Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту. Применение шаблона информационный эксперт повышает связность модулей и не противоречит свойству инкапсуляции.
- **_Creator (Создатель)_** – суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с абстрактной фабрикой.
- **_Controller (Контроллер)_** – призван решить проблему разделения интерфейса и логики в интерактивном приложении. Это не что иное, как хорошо известный контроллер из MVC парадигмы. Контролер отвечает за обработку запросов и решает кому должен делегировать запросы на выполнение. Если обобщить назначение сontroller, то он должен отвечать за обработку входных системных сообщений.
- Low Coupling (Слабая связанность) – если объекты в приложении сильно связанны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает множество проблем. Low coupling как раз говорит о том что необходимо, чтобы код был слабо связан и зависел только от абстракций.
- High Cohesion (Высокая связанность) – класс должен стараться выполнять как можно меньше не специфичных для него задач, и иметь вполне определенную область применения (тесно связан с Single Responsibility Principle.

Дополнительные шаблоны:
- **_Pure Fabrication (Чистая выдумка)_** – существует понятие модели программирования по предметной области, согласно которой, каждой сущности из предметной области соответствует один или более классов программной среды. При этом, обязанности взаимодействия сущностей, как правило накладываются на них самих. Такой подход имеет очевидный недостаток — высокая связность модулей системы. Шаблон чистая выдумка позволяет решить данную проблему, путем введения в программную среду дополнительного класса (не отражающего реальной сущности из предметной области) и наделение его требуемыми обязанностями.
- **_Indirection (Посредник)_** – реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту — посреднику.
- **_Polymorphism (Полиморфизм)_** – позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) по-разному несмотря не то, что они оба подклассы Shape, метод render определен в Shape.
- **_Protected Variations (Устойчивость к изменениям)_** – суть этого принципа в том, чтобы определить места в системе, где поведение может изменится и выделить абстракцию, на основе которой и будет происходить дальнейшее программирование с использованием этого объекта. Все это делается лишь для того, чтобы обеспечить устойчивость интерфейса. Если будет много изменений связанных с объектами, он, в таком случае считается неустойчивым, и тогда нужно выносить его в абстракцию, от которой он и будет зависеть, либо же распределять обязанности и ответственность в коде иным образом.

https://habr.com/ru/articles/92570/
https://bool.dev/blog/detail/grasp-printsipy
https://alishoff.com/blog/365
</details>

<details><summary><b>Типы полиморфизма?</b></summary>

**Полиморфизм подтипов.** Это полиморфность «по умолчанию»: когда в ООП говорят о полиморфизме, обычно имеют в виду его. Выше мы рассказывали именно про такой тип. Это возможность использовать одни и те же команды, или интерфейсы, для разных сущностей — подтипов.

**Параметрический полиморфизм.** Его еще называют обобщенным полиморфизмом. В нем для команды не имеет значения, какую сущность ей прислали: для всех возможных классов будет использоваться один код. Такой полиморфизм считается «истинным» и делает код универсальнее, но реализовать его сложнее.

    public static <T extends Comparable<? super T>> void sort(List<T> list)

**Полиморфизм ad hoc.** Этот вид полиморфизма еще называют специализированным. Это вид полиморфизма при котором в зависимости от типа данных применяются различные функции. Его иногда противопоставляют параметрическому: идея ad hoc — разный код при одинаковом названии. Часто такой полиморфизм реализуют с помощью перегрузки методов: несколько раз пишут метод с одним и тем же названием, но разным кодом.

    public class Program {
        static int sum(int x, int y){
            return x + y;
        }

	    static double sum(double x, double y){
		    return x + y;
	    }
	
	    static int sum(int x, int y, int z){
	    	return x + y + z;
	    }
    }
</details>

<details><summary><b>Можно ли в JavaScript реализовать абстрактный класс и как это сделать?</b></summary>

Абстрактные классы представляют классы, определенные с ключевым словом abstract. Они во многом похожи на обычные классы за тем исключением, что мы не можем создать напрямую объект абстрактного класса, используя его конструктор.

Как правило, абстрактные классы описывают сущности, которые в реальности не имеют конкретного воплощения. Например, геометрическая фигура может представлять круг, квадрат, треугольник, но как таковой геометрической фигуры самой по себе не существует. Есть конкретные фигуры, с которыми мы и работаем. В то же время все фигуры могут иметь какой-то общий функционал. В этом случае мы можем определить абстрактный класс фигуры, поместить в него общий функционал, и от него унаследовать классы конкретных геометрических фигур:

    abstract class Figure {
        getArea(){
            console.log("Not Implemented")
        }
    }
    
    class Rectangle extends Figure{
        constructor(public width, public height){ 
            super();
        }
         
        getArea(){
            let square = this.width * this.height;
            console.log("area =", square);
        }
    }
    
    let someFigure = new Rectangle(20, 30)
    someFigure.getArea();   // area = 600

В данном случае абстрактный класс определяет метод getArea(), который вычисляет площадь фигуры. Класс прямоугольника определяет свою реализацию для этого метода.

https://metanit.com/web/typescript/3.12.php
</details>

<details><summary><b>Разница между императивным и декларативным подходами программирования?</b></summary>

**_Декларативное программирование_** - это когда в коде описано, что должно получиться, а **_императивное_** - когда написано как это сделать. 

Т.е. в первом случае мы совершенно не интересуемся, каким именно образом машина сделает работу, какие инструкции в каком порядке выполнятся и так далее, мы просто объясняем ей, что хотим увидеть в результате. Примеры декларативных языков - html, css, sql, конфиг nginx. Ещё тут стоит упомянуть функциональные языки (lisp, haskell), программы на них тоже, как правило, являются описанием (декларацией) того "что должно получиться". Мы говорим компьютеру: вот смотри, мне надо чтобы было так, а как ты это сделаешь, мне неинтересно. _Аналогия такая_: у меня есть чертёж бани, я даю его бригаде строителей и уезжаю. Как именно они там будут таскать брёвна, пилить доски и прочее - я не в курсе.

Программируя императивно, мы описываем конкретные шаги, действия и точный порядок, в котором их нужно исполнять. Напрямую руководим процессом, непосредственно отдаём приказания. Большинство популярных языков императивны, в том числе и javascript. Мы пишем: вот, сделай-ка переменную myVar, потом запиши туда число 5, повторяй это до тех пор, пока что-то не случится... и так далее. _Возвращаясь к примеру_ с баней, ты теперь - начальник бригады, именно говоришь какое бревно куда класть.
</details>

<details><summary><b>Что такое реактивное программирование?</b></summary>

Реактивность – это способ автоматически обновлять систему в зависимости от изменения потока данных.

Реактивность – это удобный способ синхронизировать данные, например, с интерфейсом, который видит пользователь. Реактивность помогает сосредоточиться на данных, как они связаны между собой, что гораздо ближе к бизнес-логике.

Реактивное программирование – парадигма в программировании, в которой программа больше сосредоточена на управлении потоками данных, таким образом описывая взаимосвязи между ними.

Реактивное программирование помогает абстрагироваться от описания действий в коде напрямую и сосредоточиться на взаимосвязи данных. Оно создано, чтобы упростить создание программ с большим количеством связей.

Основная идея реактивности строится на паттерне «Наблюдатель» (Observer). Это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий другим следить и реагировать на события, происходящие в источнике. А вот в какой момент подписчики узнают об обновлениях, зависит от типа реактивности. Она бывает двух типов: push и pull.

Когда в реактивной системе по методу **push** происходит изменение, она самостоятельно проталкивает (от англ. push – «толкать») это изменение всем подписчикам. При таком типе реактивности все подписчики будут получать актуальные изменения сразу, как только они произошли.

Реактивность по методу **pull** работает противоположно push-реактивности. Вычисления, вызванные изменением данных в источнике, здесь откладываются до тех пор, пока не будут нужны. При таком типе реактивности подписчики вытянут (от англ. «pull» – тянуть) новые данные, только когда обновится вся система.

https://doka.guide/js/reactivity/
</details>

<details><summary><b>Плюсы и минусы реактивного программирования?</b></summary>

**Преимущества:**
1. **Отзывчивость**: Реактивное программирование позволяет создавать отзывчивые приложения, которые реагируют на изменения данных и событий в реальном времени. Пользователи могут видеть изменения в интерфейсе без задержек, что повышает качество пользовательского опыта.
2. **Масштабируемость**: Реактивное программирование позволяет обрабатывать большие объемы данных и событий эффективно, так как операции могут быть выполнены асинхронно и параллельно. Это делает реактивные приложения масштабируемыми и способными справляться с высокими нагрузками.
3. **Гибкость**: Реактивное программирование предлагает гибкость в обработке данных. Операторы могут быть комбинированы и переиспользуемы, что позволяет создавать сложные операции обработки данных из простых компонентов. Это делает код более модульным, легко поддерживаемым и расширяемым.
4. **Упрощение сложных асинхронных операций**: Реактивные операторы предлагают абстракцию для обработки сложных асинхронных операций, таких как асинхронные вызовы API, обработка событий, работа с потоками данных и других асинхронных задач. Это позволяет разработчикам упростить сложный асинхронный код и избежать проблем, таких как "callback hell" (ад на англ.), который может возникнуть при работе с асинхронными операциями.
5. **Легкая интеграция**: Реактивное программирование может быть легко интегрировано в различные типы приложений и архитектур, такие как клиент-серверные приложения, веб-приложения, мобильные приложения и другие. Реактивные библиотеки и фреймворки доступны на множестве языков программирования, таких как Java, JavaScript, Scala, Kotlin, и других, что делает их универсальными и гибкими для различных технологических стеков.

**Недостатки:**
1. **Легко усложнить ситуацию**. Когда разработчики связывают слишком много операторов вместе или пытаются создать с помощью операторов слишком сложный набор функций, может стать трудно понять, что происходит.
2. **Непонимание основных понятий**. Многие разработчики считают, что реактивное программирование по своей сути является многопоточным; Это не обязательно так; многие операторы/функции работают последовательно, независимо от того, выполняется ли общий эффект в нескольких потоках или нет, зависит от используемых планировщиков или применяемых операторов.
3. **Накладные расходы на память.** Некоторые приложения могут потреблять слишком много памяти. Это связано с тем, что потоки данных должны хранить опубликованные данные, чтобы наблюдатели могли обрабатывать эти данные, когда они будут готовы.

</details>

<details><summary><b>Что такое Inversion of control?</b></summary>

Инверсия управления (IoC) — это абстрактный принцип программирования, основанный на потоке управления (выполнении операторов/инструкций), который должен полностью управляться конкретной реализацией платформы, внешней по отношению к вашему коду.

При традиционном подходе ваш код выполняет методы из библиотеки/фреймворка, а инверсия этого подхода означает, что ваш код вызывается библиотекой/фреймворком. Думайте об этом так: "Сократите функционал вашей абстракции, и сделайте так чтобы ваши пользователи сами могли реализовывать нужный им функционал".

Пример:

    function filter(
        array,
        {
            filterNull = true,
            filterUndefined = true,
            filterZero = false,
            filterEmptyString = false,
        } = {},
    ) {
        let newArray = []
        for (let index = 0; index < array.length; index++) {
            const element = array[index]
            if (
                (filterNull && element === null) ||
                (filterUndefined && element === undefined) ||
                (filterZero && element === 0) ||
                (filterEmptyString && element === '')
            ) {
                continue
            }
            newArray[newArray.length] = element
        }
        return newArray
    }
    
    filter([0, 1, undefined, 2, null, 3, 'four', ''])
    // [0, 1, 2, 3, 'four', '']
    
    filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterNull: false})
    // [0, 1, 2, null, 3, 'four', '']
    
    filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterUndefined: false})
    // [0, 1, 2, undefined, 3, 'four', '']

Теперь напишем более продуманную абстракцию к этой функции и применим метод инверсии управления для поддержки всех нужных нам вариантов использования:

    function filter(array, filterFn) {
        let newArray = []
        for (let index = 0; index < array.length; index++) {
            const element = array[index]
            if (filterFn(element)) {
                newArray[newArray.length] = element
            }
        }
        return newArray
    }
    
    filter(
        [0, 1, undefined, 2, null, 3, 'four', ''],
        el => el !== null && el !== undefined,
    )
    // [0, 1, 2, 3, 'four', '']
    
    filter([0, 1, undefined, 2, null, 3, 'four', ''], el => el !== undefined)
    // [0, 1, 2, null, 3, 'four', '']
    
    filter([0, 1, undefined, 2, null, 3, 'four', ''], el => el !== null)
    // [0, 1, 2, undefined, 3, 'four', '']
    
    filter(
        [0, 1, undefined, 2, null, 3, 'four', ''],
        el => el !== undefined && el !== null && el !== 0,
    )
    // [1, 2, 3, 'four', '']


[Хорошая статья с примерами] https://habr.com/ru/articles/485012/

</details>

<details><summary><b>Что такое Dependency injection? Разница между агрегацией и композицией?</b></summary>
Внедрение зависимостей — это решение, при котором система предоставляет целевые зависимости из внешних источников; вместо того, чтобы требовать, чтобы цель сама создавала эти зависимости. Зависимости — это сервисы, объекты, функции или значения, которые необходимы классу (или фабрике, функции) для выполнения своей функции.
В React можно добиться через props, Context или сторонние библиотеки (InversifyJS).

**Ассоциация** – знание одного класса о другом. Например, класс Начальник может быть связан с классом Подчиненный отношением ассоциации, чтобы передавать ему запросы. Если и Подчиненный должен обращаться к Начальнику – ассоциация называется двунаправленной.

Агрегация и композиция – две разновидности ассоциации. **Композиция** подразумевает, что ассоциированный объект – «подобъект», составная часть, не имеющая смысла без ссылающегося. На практике, например, отношение композиции появляется когда мы выделяем часть свойств объекта в отдельную сущность.

**Агрегация** не подразумевает отношения владения. Это просто ссылка на другой, самостоятельный объект. Он может продолжить функционировать, если ссылающийся объект прекратит существование. Например, класс-контейнер агрегирует хранимые элементы.
</details>

<details><summary><b>Разница между процедурным и функциональным программированием?</b></summary>

**Процедурное программирование (ПП)**, также известное как встроенное программирование, использует нисходящий подход. Речь идет о написании списка инструкций, которые будут указывать компьютеру, что делать шаг за шагом. Он опирается на процедуры или подпрограммы.
В процедурном решении программа разбита на подпрограммы, изменяющие состояние вместо возврата значения.

**Функциональное программирование (ФП)** заключается в передаче данных от функции к функции, чтобы получить результат. В ФП функции обрабатываются как данные, что означает, что вы можете использовать их в качестве параметров, возвращать их, создавать функции из других функций и создавать пользовательские функции. Функции в ФП должны быть чистыми функциями, они должны избегать общего состояния, а побочные эффекты и данные должны быть неизменяемыми. Чистая функция - это функция, которая при одном и том же типе входных данных всегда будет возвращать один и тот же вывод, она не зависит от локального или глобального состояния. Общее состояние - это состояние, которое совместно используется более чем одной функцией или более чем одной структурой данных. Таким образом, с общим состоянием, чтобы понять эффекты функции, вам нужно знать все детали каждой общей переменной. Это добавляет много сложности и допускает меньшую модульность.

**Объектно-ориентированное программирование (ООП)** заключается в инкапсуляции данных и поведения в объекты. Приложение ООП будет использовать коллекцию объектов, которая знает, как выполнять определенные действия и как взаимодействовать с другими элементами приложения. Например, объектом может быть человек. У этого человека было бы имя (которое было бы свойством объекта), и он знал бы, как ходить (это был бы метод). Метод в ООП можно рассматривать как процедуру в ПП, но здесь он принадлежит конкретному объекту. Другим важным аспектом ООП являются классы. Класс можно рассматривать как схему объекта.

https://ru.hexlet.io/courses/python-declarative-programming/lessons/imperative-and-functional-python/theory_unit

</details>

